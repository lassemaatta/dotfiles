#+TITLE: Emacs Configuration
#+STARTUP: showall
* Table of Contents                                            :TOC:noexport:
- [[#preamble][Preamble]]
- [[#load-initial-configuration][Load initial configuration]]
  - [[#disable-gc-while-loading][Disable GC while loading]]
  - [[#bootstrap-use-package][Bootstrap =use-package=]]
  - [[#load-optional-local-settings][Load optional local settings]]
  - [[#generate-toc][Generate TOC]]
- [[#general-configuration-for-emacs][General configuration for =emacs=]]
  - [[#quality-of-life][Quality-of-Life]]
  - [[#backups][Backups]]
  - [[#performance][Performance]]
  - [[#scrolling][Scrolling]]
  - [[#whitespace][Whitespace]]
  - [[#help-helpful][Help (=helpful=)]]
  - [[#file-system-dired][File system (=dired=)]]
  - [[#ui][UI]]
- [[#general-programming][General programming]]
- [[#packages][Packages]]
  - [[#theming][Theming]]
  - [[#utilities][Utilities]]
  - [[#project-and-file-management][Project and File Management]]
  - [[#programming][Programming]]
- [[#postamble][Postamble]]

* Preamble
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
  ;;; settings.el --- My custom config
  ;;; Commentary:
  ;;; Code:
#+END_SRC
* Load initial configuration
:PROPERTIES:
:VISIBILITY: folded
:END:

** Disable GC while loading

The =early-init.el= disables garbage collection at startup. Here we re-enable it once startup is complete.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 128 1024 1024))))
#+END_SRC

** Bootstrap =use-package=

#+BEGIN_SRC emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))

  (defvar my-package-list '(use-package))

  (dolist (package my-package-list)
    (unless (package-installed-p package)
      (package-install package)))

  (require 'use-package)
#+END_SRC

Always install all packages.

#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t
        use-package-verbose t
        use-package-compute-statistics t)
#+END_SRC

** Load optional local settings

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/init/")
  (require 'init-local nil t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/emacs-custom.el")
  (load custom-file)
#+END_SRC

** Generate TOC

Use [[https://github.com/snosov1/toc-org][toc-org]] to generate a Table of Contents for this document for github.

#+BEGIN_SRC emacs-lisp
  (use-package toc-org
    :after org
    :hook ((org-mode) . toc-org-mode))
#+END_SRC

* General configuration for =emacs=
** Quality-of-Life

Don't  require the user to type =yes= or =no= as a simple =y= or =n= is sufficient.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Automatically refresh buffers if the file has changed on disk.

#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src

** Backups

#+BEGIN_SRC emacs-lisp
  (setq
   ;; don't clobber symlinks
   backup-by-copying t
   ;; don't litter my fs tree
   backup-directory-alist '(("." . "~/.saves/"))
   auto-save-file-name-transforms `((".*" "~/.saves/" t))
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   ;; use versioned backups
   version-control t)
#+END_SRC

** Performance

Increase the default number of bytes to read from subprocesses, as the default is just 4 kB.

#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+END_SRC

The =suggest-key-bindings= feature adds several seconds of delays to various commands when using =M-x=.

#+BEGIN_SRC emacs-lisp
  (setq suggest-key-bindings nil)
#+END_SRC

Enable shortcuts for the internal profiler

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f9>") 'profiler-start)
  (global-set-key (kbd "<f10>") 'profiler-stop)
  (global-set-key (kbd "<f11>") 'profiler-report)
#+END_SRC

Use left-to-right text direction instead of detecting per line, for a minor perfomance boost.

#+BEGIN_SRC emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)
#+END_SRC

Disable the bidirectional parenthesis algorithm, for a minor performance boost.

#+BEGIN_SRC emacs-lisp
  (setq bidi-inhibit-bpa t)
#+END_SRC

** Scrolling

Set =scroll-margin= to =0= , otherwise the scrolling will jump around when clicking on entries in =treemacs=.

#+BEGIN_SRC emacs-lisp
  (setq auto-window-vscroll nil
        fast-but-imprecise-scrolling t
        scroll-conservatively 101
        scroll-margin 0
        scroll-preserve-screen-position t)
#+END_SRC

** Whitespace

Highlight trailing whitespace (when not in read-only buffers) and don't use tabs for indenting.

#+BEGIN_SRC emacs-lisp
  (defun show-trailing-if-writeable ()
    (let ((enabled (if buffer-read-only nil t)))
      (setq-local show-trailing-whitespace enabled)
      (setq-local indicate-empty-lines enabled)))

  (add-hook 'text-mode-hook 'show-trailing-if-writeable)
  (add-hook 'prog-mode-hook 'show-trailing-if-writeable)
  (add-hook 'read-only-mode-hook 'show-trailing-if-writeable)

  (setq-default indent-tabs-mode nil)
#+END_SRC

Highlight any tabs as if they were trailing whitespace. Again, only in writable buffers.

#+BEGIN_SRC emacs-lisp
  (add-hook 'font-lock-mode-hook
            (lambda ()
              (when (not buffer-read-only)
                (font-lock-add-keywords
                 nil
                 '(("\t" 0 'trailing-whitespace prepend))))))
#+END_SRC

Cleanup trailing whitespace when saving a buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Help (=helpful=)

[[https://github.com/Wilfred/helpful][helpful]] provides some additional information in help buffers, such as keymaps or call locations.

#+begin_src emacs-lisp
  (use-package helpful
    :bind
    (([remap describe-key]      . helpful-key)
     ([remap describe-command]  . helpful-command)
     ([remap describe-variable] . helpful-variable)
     ([remap describe-function] . helpful-callable)
     :map emacs-lisp-mode-map
     ("C-c C-d" . helpful-at-point)))
#+end_src

** File system (=dired=)

Re-use the same buffer when navigating to subdirectories in =dired=.

#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

#+begin_src emacs-lisp
  (use-package dirvish
    :init
    (dirvish-override-dired-mode))
#+end_src

** UI

Hide the default splash screen.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

Dim other windows to make it easier to see the active window.

#+begin_src emacs-lisp
  (use-package auto-dim-other-buffers
    :init
    (auto-dim-other-buffers-mode t))
#+end_src

Highlight the current line.

#+begin_src emacs-lips
  (global-hl-line-mode)
#+end_src

Use =ace-window= to quickly move between windows.

#+begin_src emacs-lisp
  (use-package ace-window
    :bind (("C-p" . ace-window))
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (aw-dispatch-always t)
    (aw-ignore-on nil))
#+end_src

*** Fonts

Detect the screen DPI and update the font accordingly [[[https://emacs.stackexchange.com/a/36074][source]]].

#+begin_src emacs-lisp
  (defun current-dpi ()
    (let* ((attrs (frame-monitor-attributes))
           (size (assoc 'mm-size attrs))
           (sizex (cadr size))
           (res (cdr (assoc 'geometry attrs)))
           (resx (caddr res))
           dpi)
      (catch 'exit
        ;; in terminal
        (unless sizex
          (throw 'exit 10))
        ;; on big screen
        (when (> sizex 1000)
          (throw 'exit 10))
        ;; DPI
        (round (* (/ (float resx) sizex) 25.4)))))
#+end_src

#+begin_src emacs-lisp
  (defvar font-family "Hack")
  (defvar font-family-variable "Source Sans Pro")
  (set-face-attribute 'default nil :family font-family :height 100)
  (set-face-attribute 'fixed-pitch nil :family font-family :height 100)
  (set-face-attribute 'variable-pitch nil :family font-family-variable :height 120)
  (set-face-attribute 'mode-line nil :font font-family)

  (defun update-font-size (font-size)
    "Update the font DPI."
    (internal-set-lisp-face-attribute
     'default :font (font-spec :family font-family
                               :size font-size) 0)
    (internal-set-lisp-face-attribute
     'fixed-pitch :font (font-spec :family font-family
                                   :size font-size) 0)
    (internal-set-lisp-face-attribute
     'variable-pitch :font (font-spec :family font-family-variable
                                      :size (+ 4 font-size)) 0))

  (defun dpi-to-font (dpi)
    (cond
     ((< dpi 140) 14)
     ;; less than 150
     ((< dpi 150) 16)
     ;; 150 - 160
     ((< dpi 160) 17)
     ;; 160 - 170
     ((< dpi 170) 19)
     ;; more than 170
     (t 17)))

  (defun refresh-dpi ()
    (interactive)
    (let* ((dpi (current-dpi))
           (font-size (dpi-to-font dpi)))
      (message (format "Detected DPI %s -> %s" dpi font-size))
      (update-font-size font-size)))

  (refresh-dpi)
#+end_src

* General programming

Show line numbers.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

Highlight matching parenthesis.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

Enable /HideShow/ mode: allows collapsing s-exprs (=<backtab>=  is =S-<tab>=).

#+begin_src emacs-lisp
  (use-package hideshow
    :hook ((clojure-mode . hs-minor-mode)
           (emacs-lisp-mode . hs-minor-mode))
    :bind (("<backtab>" . hs-toggle-hiding)))
#+END_src

Indent current function

#+begin_src emacs-lisp
  (defun er-indent-defun ()
    "Indent the current defun."
    (interactive)
    (save-excursion
      (mark-defun)
      (indent-region (region-beginning) (region-end))))

  (global-set-key (kbd "C-<tab>") #'er-indent-defun)
#+end_src

Emacs uses coarse regexp based parsers for syntax highlighting. =tree-sitter= provides language-specific parsers, which are both faster and provide more accurate results. However, not all languages are yet supported.

#+begin_src emacs-lisp
  (use-package tree-sitter
    :hook ((;; Disable for clojure, as syntax highlighting doesn't seem to be available yet
            ;; clojure-mode
            ;; clojurec-mode
            ;; clojurescript-mode
            java-mode
            javascript-mode
            json-mode)
           . tree-sitter-hl-mode)
    :config
    ;; (add-to-list 'tree-sitter-major-mode-language-alist '(clojure-mode . clojure))
    (global-tree-sitter-mode))

  (use-package tree-sitter-langs
    :after tree-sitter)
#+end_src

* Packages
** Theming

Provide icons for stuff like =treemacs=.

#+BEGIN_SRC emacs-lisp
    (use-package all-the-icons)
#+END_SRC

Provide icons for completion menus (e.g. when selecting which file to open etc.).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-completion
    :after all-the-icons)
#+END_SRC

Construct a simple modeline.

#+BEGIN_SRC emacs-lisp
  (setq-default projectile-mode-line-prefix "")

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-frame-identification
                  projectile--mode-line
                  " "
                  mode-line-buffer-identification
                  " "
                  (vc-mode vc-mode)
                  " "
                  mode-name
                  " "
                  flycheck-mode-line
                  " "
                  mode-line-misc-info
                  " "
                  mode-line-process
                  " "
                  mode-line-end-spaces))
#+END_SRC

Use =modus-vivendi= as the main theme.

#+BEGIN_SRC emacs-lisp
  (use-package modus-themes
    :custom
    (modus-themes-org-blocks 'gray-background)
    (modus-themes-mixed-fonts t)
    :config
    (load-theme 'modus-vivendi :no-confirm))
#+END_SRC

** Utilities
*** Keybindings

Use [[https://github.com/justbur/emacs-which-key][which-key]] to show suggestions when using keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (which-key-mode)
    :custom
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-separator ":")
    (which-key-max-description-length 120)
    (which-key-side-window-max-width 50)
    (which-key-idle-delay 1.00)
    :config
    (which-key-setup-side-window-right-bottom))
#+END_SRC

*** Minibuffer completion (=vertico=)

Hide commands in =M-x= which do not apply to the current mode.

#+BEGIN_SRC emacs-lisp
  (setq read-extended-command-predicate #'command-completion-default-include-p)
#+END_SRC

[[https://github.com/minad/vertico][vertico]] provides completion for minibuffer commands.

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :init
    (vertico-mode))
#+END_SRC

[[https://github.com/oantolin/orderless][orderless]] provides /completion style/ (ie. fuzzy searching) for command completion.

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :after vertico
    :custom
    (completion-styles '(basic orderless partial-completion))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

[[https://github.com/minad/cape][cape]] provides extensions and utilities to =completion-at-point-functions=.

#+BEGIN_SRC emacs-lisp
  (use-package cape
    :after vertico)
#+END_SRC

The [[https://github.com/minad/marginalia][marginalia]] package provides description of entries (e.g. files, commands) in completion menus.

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :after (vertico all-the-icons-completion)
    :init
    (add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup)
    (marginalia-mode))
#+END_SRC

The [[https://github.com/minad/consult][consult]] package provides a bunch of utility functions related to completions (e.g. switch buffer, search within buffer..).

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :demand t
    :after (projectile)
    :bind (("C-s" . consult-line)
           ("C-x b" . consult-buffer)
           ("C-M-y" . consult-yank-from-kill-ring))
    :custom
    (consult-narrow-key "<")
    (consult-project-function (lambda (_)
                                (projectile-project-root)))
    :config
    (defun my-consult-ripgrep-with-default ()
      "Run `consult-ripgrep' using the sexp-at-point as the initial search argument"
      (interactive)
      (consult-ripgrep nil (thing-at-point 'sexp)))
    (substitute-key-definition 'projectile-ripgrep 'my-consult-ripgrep-with-default projectile-command-map))
#+END_SRC

#+begin_src emacs-lisp
  (use-package consult-projectile
    :demand t
    :after consult
    :config
    (substitute-key-definition 'projectile-find-file
                               'consult-projectile
                               projectile-command-map))
#+end_src

The [[https://github.com/oantolin/embark][embark]] package provides a way to run commands against the currently active minibuffer target (e.g. =C-x C-f= to browse files, then =C-ä= to choose an action on a file).

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :after vertico
    :bind (("C-ä" . embark-act)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :after (embark consult))
#+END_SRC

Use =savehist= to save minibuffer command history between sessions.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))
#+END_SRC

Close the minibuffer if you click on a buffer.

#+begin_src emacs-lisp
  (defun stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))

  (add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)
#+end_src

*** Search

[[https://github.com/dajva/rg.el][rg]] provides [[https://github.com/BurntSushi/ripgrep][ripgrep]] searching within =emacs=.

#+BEGIN_SRC emacs-lisp
  (use-package rg
    :defer t)
#+END_SRC

*** Org mode

#+begin_src emacs-lisp
  (use-package org
    :defer t
    :custom
    ;; Enable syntax highlighting when exporting as PDFs. Requires the =minted= package for LaTeX.
    (org-latex-listings 'minted)
    (org-latex-pdf-process
     '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (org-babel-clojure-backend 'cider)
    (org-babel-clojure-sync-nrepl-timeout nil)
    (org-clock-persist t)
    :mode ("\\.org\\'" . org-mode)
    :hook (org-mode . org-mode-init)
    :config
    (require 'org-indent)
    (defun org-mode-init ()
      (org-indent-mode 1)
      (variable-pitch-mode 1)
      (visual-line-mode 1))
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((clojure . t)
       (emacs-lisp . t)
       (http . t)
       (dot . t)))
    (org-clock-persistence-insinuate))

  (use-package ob-http
    ;:defer t
    :after org
    :config
    (message "Loaded ob-http"))
#+end_src

As =org-hide-emphasis-markers= hides the styling, we can use =org-appear= to undo that when the point enters a styled word. The =org-appear-autolinks= does the same to links.

#+begin_src emacs-lisp
  (use-package org-appear
    :after org
    :hook ((org-mode . org-appear-mode))
    :custom
    (org-hide-emphasis-markers t)
    (org-appear-autolinks t)
    :config
    (message "Loaded org-appear"))
#+end_src

=polymode= offers /multiple major modes/ inside a single buffer.

Disable LSP within a nested block as it causes the point to jump around (see [[https://github.com/polymode/polymode/issues/316][bug]]).

#+begin_src emacs-lisp
  (use-package polymode
    :defer t
    :config
    (setq-default polymode-lsp-integration nil))

  (use-package poly-org
    :defer t
    :after polymode)

  (defun load-polymode()
    (interactive)
    (require 'polymode)
    (poly-org-mode +1))
#+end_src

*** Notekeeping (=org-roam=)

Use [[https://www.orgroam.com/][org-roam]] for notekeeping and timetracking.

#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-directory "~/org-roam")
    :bind (:prefix "C-c n"
           :prefix-map org-roam
           ("l" . org-roam-buffer-toggle)
           ("f" . org-roam-node-find)
           ("i" . org-roam-node-insert))
    :config
    (org-roam-db-autosync-mode))
#+END_SRC

*** Better undo (=undo-tree=)

[[https://gitlab.com/tsc25/undo-tree][undo-tree]] provides a nice tree-view of the undo history.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :custom
    (undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
    (undo-tree-auto-save-history nil)
    :config
    (global-undo-tree-mode))
#+END_SRC

** Project and File Management
*** Startup Dashboard (=dashboard=)

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] shows a list of recent projects and files when opening =emacs=.

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :after (projectile)
    :custom
    (dashboard-center-content t)
    (dashboard-set-heading-icons t)
    (dashboard-projects-backend 'projectile)
    (dashboard-items '((bookmarks . 5)
                       (projects . 5)
                       (recents . 10)))
    :config
    (dashboard-setup-startup-hook))
#+END_SRC

*** File Explorer (=treemacs=)

[[https://github.com/Alexander-Miller/treemacs][treemacs]] offers a Eclipse-like project explorer.

Note that we exclude some build directories so that changes in files don't propagate to =treemacs=.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :bind (("<f1>" . treemacs)
           ("<f5>" . treemacs-find-file))
    :custom
    (treemacs-space-between-root-nodes nil)
    :config
    (define-key treemacs-mode-map [drag-mouse-1] nil)
    (treemacs-follow-mode -1)
    (defun treemacs-ignore (filename absolute-path)
      (or (cl-search "/.shadow-cljs" absolute-path)
          (cl-search "/.idea" absolute-path)
          (cl-search "/target" absolute-path)
          (cl-search "/node_modules" absolute-path)))
    (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore))

  (use-package treemacs-all-the-icons
    :after (treemacs))
#+END_SRC

*** Project Management (=projectile=)

[[https://github.com/bbatsov/projectile][projectile]] is used for managing projects.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :after (vertico)
    :custom
    (projectile-completion-system 'default)
    (projectile-project-search-path '("~/work/"))
    (projectile-switch-project-action #'projectile-dired)
    (projectile-enable-caching t)
    :init
    (projectile-mode +1)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
#+END_SRC

Integration with [[https://github.com/Alexander-Miller/treemacs][treemacs]].

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-projectile
    :after (treemacs projectile))
#+END_SRC

*** Git

[[https://magit.vc/][magit]] provides a really nice =git= UI.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :custom
    (magit-diff-refine-hunk 'all)
    :commands (magit-status))
#+END_SRC

Use =treemacs-magit= to update the =treemacs= view when =magit= updates the =git= repository state.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-magit
    :after (magit treemacs))
#+END_SRC

[[https://github.com/dgutov/diff-hl][diff-hl]] highlights modified lines in the gutter.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :hook ((prog-mode . global-diff-hl-mode)
           (dired-mode . diff-hl-dired-mode)
           (magit-pre-refresh . diff-hl-magit-pre-refresh)
           (magit-post-refresh . diff-hl-magit-post-refresh)))
#+END_SRC

** Programming

*** Error checking (=flycheck=)

#+begin_src emacs-lisp
  (use-package flycheck
    :hook ((prog-mode . flycheck-mode))
    :custom
    (flycheck-display-errors-delay 0.1))
#+end_src

[[https://github.com/minad/consult-flycheck][consult-flycheck]] provides a nice `consult-flycheck` command for navigating =flycheck= errors.

#+begin_src emacs-lisp
  (use-package consult-flycheck
    :after (consult flycheck)
    :bind (("C-d" . consult-flycheck)))
#+end_src

Use [[https://github.com/flycheck/flycheck-inline][flycheck-inline]] to display errors under the point.

#+begin_src emacs-lisp
  (use-package flycheck-inline
    :hook ((flycheck-mode . flycheck-inline-mode)))
#+end_src

*** Completion (=corfu=)

Regardless of completion provider, always try to complete =<tab>=.

#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src

Use [[https://github.com/minad/corfu][corfu]] for completion at point functionality, similar to =company=.

While completing, use =S-SPC= to add a separator, which does not abort the completion but instead allows you to add more search words.

When looking at completion candidates with =corfu=, we can use =corfu-popupinfo= to show a documentation popup with docstrings et al.

#+begin_src emacs-lisp
  (use-package corfu
    :init
    (global-corfu-mode)
    (corfu-popupinfo-mode)
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history)
    :bind (("S-SPC" . corfu-insert-separator)
           (:map corfu-map
                 ("TAB" . corfu-next)
                 ([tab] . corfu-next)
                 ("S-TAB" . corfu-previous)
                 ([backtab] . corfu-previous)))
    :custom
    (corfu-auto nil)
    (corfu-preselect 'prompt)
    (corfu-popupinfo-delay '(0.5 . 1.0))
    (corfu-cycle t)
    (corfu-on-exact-match nil)
    (corfu-quit-no-match nil))
#+end_src

Add icons to completion menu with =kind-icon=.

#+begin_src emacs-lisp
  (use-package kind-icon
    :ensure t
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default)
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

Use =my-refresh-completions= to setup the =completion-at-point-functions= as various minor modes often alter it in ways we don't like. We use =company= just for =company-yasnippet= support.

#+begin_src emacs-lisp
  (use-package company
    :defer t)

  (defun my-wrap-with-pred (capf pred)
    (lambda (&rest args)
      (when (funcall pred)
        (apply capf args))))

  (defun my-previous-char-whitespace ()
    (memq (char-before) (list ?\s)))

  (defun my-previous-char-point ()
    (memq (char-before) (list ?.)))

  (defun my-previous-paren-closed ()
    "Check if previous parenthesis before point is a closing parenthesis"
    (save-excursion
      (let ((match (re-search-backward "[\(\)]" (line-beginning-position) t nil)))
        (and match (memq (char-after) (list ?\)))))))

  (defun my-find-java-method-invokation ()
    "Check if we are writing a Java method invocation"
    (save-excursion
      (re-search-backward "[\.][[:alpha:]]+" (line-beginning-position) t nil)))

  (defun my-valid-snippet-point ()
    "Return `nil' if point is after a `.'"
    (or (my-previous-paren-closed)
        (my-previous-char-whitespace)
        (and (not (my-previous-char-whitespace))
             (not (my-previous-char-point))
             (not (my-find-java-method-invokation)))))

  (defun my-refresh-completions ()
    (interactive)
    (message (format "Refreshing completion providers: %s" (buffer-name)))
    (setq-local completion-at-point-functions
                (list #'cape-file
                      (apply 'cape-super-capf
                             (-concat
                              (list (my-wrap-with-pred
                                     (cape-company-to-capf #'company-yasnippet)
                                     #'my-valid-snippet-point))
                              (when (and (boundp 'lsp-mode) lsp-mode)
                                (message "LSP active")
                                (list #'lsp-completion-at-point))
                              (when (and (boundp 'cider-mode) cider-mode)
                                (message "CIDER active")
                                (list #'cider-complete-at-point)))))))
#+end_src

*** Snippets

[[https://github.com/joaotavora/yasnippet][yasnippet]] provides snippet functionality.

#+begin_src emacs-lisp
  (use-package yasnippet
    :hook ((prog-mode . yas-minor-mode))
    :bind (:map yas-minor-mode-map
           ("TAB" . nil)
           ("<tab>" . nil)))
#+end_src

Load some =clojure= specific snippets.

#+begin_src emacs-lisp
  (use-package clojure-snippets
    :after (yasnippet)
    :config
    (yas-reload-all))
#+end_src

[[https://github.com/mohkale/consult-yasnippet][consult-yasnippet]] provides a nice list with previews when choosing a snippet.

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :after (yasnippet)
    :bind  (("C-ö" . consult-yasnippet)))
#+end_src

*** Language Server Protocol
**** General Setup

See the [[https://github.com/minad/corfu/wiki#advanced-example-configuration-with-orderless][Corfu wiki]] on how =corfu= and =orderless= completion can be configured for =lsp-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :defer 0
    :custom
    (lsp-completion-provider :none)
    ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
    (lsp-keymap-prefix "C-c l")
    (lsp-idle-delay 0.5)
    (lsp-eldoc-enable-hover nil)
    (lsp-lens-enable t)
    ;; Close LSP server when last buffer closed
    (lsp-keep-workspace-alive t)
    ;; We use yasnippet, but not through LSP
    (lsp-enable-snippet nil)
    ;; Prefer clojure-mode indentation
    (lsp-enable-indentation nil)
    (lsp-modeline-code-actions-enable nil)
    (lsp-imenu-index-function #'lsp-imenu-create-categorized-index)
    ;; For logging IO between client and server
    (lsp-log-io nil)
    ;;(lsp-clojure-custom-server-command '("bash" "-c" "/home/lassemaatta/Lataukset/clojure-lsp"))
    :init
    (defun my/lsp-mode-setup-completion ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless)))
    :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
           (clojure-mode . lsp)
           (clojurescript-mode . lsp)
           (clojurec-mode . lsp)
           (js-mode . lsp)
           (typescript-mode . lsp)
           ;; if you want which-key integration
           (lsp-mode . lsp-enable-which-key-integration)
           (lsp-completion-mode . my/lsp-mode-setup-completion)
           (lsp-completion-mode . my-refresh-completions))
    :bind (("<C-return>" . lsp-find-definition)
           ("<C-.>" . lsp-find-definition)
           ("<C-M-return>" . lsp-describe-thing-at-point))
    :commands (lsp lsp-deferred))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :custom
    (lsp-ui-sideline-show-code-actions nil)
    (lsp-ui-sideline-enable nil)
    (lsp-ui-doc-show-with-cursor t)
    (lsp-ui-doc-show-with-mouse nil)
    (lsp-ui-doc-use-childframe nil)
    (lsp-ui-peek-list-width 75) ; Default is 50
    (lsp-ui-peek-peek-height 40) ; Default is 20 rows
    :bind (("M-." . lsp-ui-peek-find-references)))
#+END_SRC

Shortcut for =imenu=, using either =lsp-ui-imenu= or =consult-imenu=
depending on whether the current buffer is using =LSP=.

#+BEGIN_SRC emacs-lisp
  (defun show-or-hide-imenu ()
    (interactive)
    (cond
     ((derived-mode-p 'lsp-ui-imenu-mode) (lsp-ui-imenu--kill))
     ((bound-and-true-p lsp-mode) (lsp-ui-imenu))
     ((active-minibuffer-window) (exit-minibuffer))
     (t (consult-imenu))))

  (global-set-key (kbd "C-u") 'show-or-hide-imenu)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package lsp-treemacs
    :bind (("<f2>" . lsp-treemacs-symbols)
           ("<f3>" . lsp-treemacs-call-hierarchy))
    :custom
    (lsp-treemacs-symbols-sort-functions '(lsp-treemacs-sort-by-name)))
#+END_SRC

=consult-lsp= provides nice utility functions such as =consult-lsp-diagnostics= or =consult-lsp-symbols=.

#+BEGIN_SRC emacs-lisp
  (use-package consult-lsp
    :after (consult lsp)
    :bind (("C-S-d" . consult-lsp-diagnostics)
           ("C-S-s" . consult-lsp-symbols)))
#+END_SRC

**** Java

#+BEGIN_SRC emacs-lisp
  (use-package lsp-java
    :defer t
    :hook ((java-mode . lsp))
    :bind (:map java-mode-map
              ("<tab>" . indent-for-tab-command))
    :custom
    (lsp-enable-snippets t)
    (lsp-java-maven-download-sources t)
    (lsp-java-java-path "/usr/lib/jvm/default-runtime/bin/java")
    (lsp-java-jdt-download-url "https://download.eclipse.org/jdtls/milestones/1.18.0/jdt-language-server-1.18.0-202212011657.tar.gz")
    :config
    (defun my-format-on-save ()
      (message "format on save")
      (when (eq major-mode 'java-mode)
        (lsp-format-buffer)))
    (add-hook 'before-save-hook 'my-format-on-save))
#+END_SRC

=lsp-java= has [[https://github.com/emacs-lsp/dap-mode/issues/533][issues]] with displaying ANSI colors when running e.g. =dap-java-run-test-class=.

#+begin_src emacs-lisp
  (defun ansi-colorize-buffer ()
    (let ((buffer-read-only nil))
      (ansi-color-apply-on-region (point-min) (point-max))))

  (use-package ansi-color
    :after (lsp-java)
    :config
    (add-hook 'compilation-filter-hook 'ansi-colorize-buffer))
#+end_src

#+begin_src emacs-lisp
  (use-package java-snippets
    :after yasnippet)
#+end_src

*** Language Modes
**** HTML

Set =.html= indentation from 2 to 4.

#+BEGIN_SRC emacs-lisp
  (add-hook 'html-mode-hook
            (lambda ()
              (set (make-local-variable 'sgml-basic-offset) 4)))
#+END_SRC

**** Docker and =docker-compose=

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package docker-compose-mode
    :defer t)
#+END_SRC

**** Graphviz and =dot=

#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :defer t
    :hook ((dot . graphviz-dot-mode))
    :custom
    (graphviz-dot-indent-width 2))
#+END_SRC

**** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :defer t)
#+END_SRC

**** Typescript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :defer t)
#+END_SRC

**** Javascript

#+BEGIN_SRC emacs-lisp
  (use-package js
    :mode ("\\.js\\'" . js-mode)
    :custom
    (js-indent-level 2))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :defer t)
#+END_SRC

[[https://github.com/DamienCassou/json-navigator][json-navigator]] provides a nice tree view of large =JSON= structures.

#+BEGIN_SRC emacs-lisp
  (use-package json-navigator
    :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :defer t
    :init
    (add-hook
     'js-mode-hook
     (lambda ()
       (unless (eq major-mode 'json-mode)
               (js2-minor-mode)))))
#+END_SRC

**** SSH config files

#+BEGIN_SRC emacs-lisp
  (use-package ssh-config-mode
    :defer t)
#+END_SRC

*** Clojure
**** =clojure-mode=

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :defer t
    :custom
    (clojure-indent-style 'align-arguments)
    (clojure-align-forms-automatically t)
    (clojure-align-separator 'entire))
#+END_SRC

**** =cider=

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :defer t
    :custom
    (nrepl-log-messages t)
    (cider-repl-buffer-size-limit 10000)
    (cider-repl-pop-to-buffer-on-connect nil)
    (cider-repl-use-clojure-font-lock t)
    (cider-save-file-on-load t)
    (cider-font-lock-dynamically '(macro core function var))
    (cider-eldoc-display-for-symbol-at-point nil)
    (cider-offer-to-open-cljs-app-in-browser nil)
    (nrepl-hide-special-buffers t)
    (cider-overlays-use-font-lock t)
    (cider-default-cljs-repl 'shadow)
    (cider-enrich-classpath nil)
    (cider-repl-history-file (concat user-emacs-directory "/cider-history"))
    :hook
    ((cider-mode . my-refresh-completions))
    :config
    (cider-repl-toggle-pretty-printing)

    (put-clojure-indent 'testit/fact 1)
    (put-clojure-indent 'testit.core/fact 1)
    (put-clojure-indent 'page/html5 1)
    (put-clojure-indent 'fact 1)
    (put-clojure-indent 'rf/reg-event-fx 1)
    (put-clojure-indent 'chain/reg-chain 1)
    (put-clojure-indent 'rf/reg-sub 1)
    (put-clojure-indent 'rf/reg-event-db 1)
    (put-clojure-indent 'futil/for-all 1)
    (put-clojure-indent 'futil/for-frag 1)
    (put-clojure-indent 'for-frag 1)
    (put-clojure-indent 'for-all 1)
    (put-clojure-indent 'u/for-all 1)
    (put-clojure-indent 'not-join 1)
    (put-clojure-indent 'r/with-let 1)
    (put-clojure-indent 'p/if-all-let 1)
    (put-clojure-indent 'test-seq/seq-tx 1))
#+END_SRC

**** =smartparens=

Note that the =*scratch*= buffer uses =emacs-lisp-mode=, therefore =smartparens= loads on startup.

#+begin_src emacs-lisp
  (use-package smartparens
    :init
    (require 'smartparens-config)
    :hook ((emacs-lisp-mode
            clojure-mode
            cider-repl-mode
            java-mode) . turn-on-smartparens-strict-mode)
    :bind (("C-<left>" . sp-backward-symbol)
           ("C-<right>" . sp-forward-symbol)
           ("M-C-<left>" . sp-backward-sexp)
           ("M-C-<right>" . sp-forward-sexp)
           ("M-7" . sp-backward-slurp-sexp)
           ("M-8" . sp-backward-barf-sexp)
           ("M-9" . sp-forward-barf-sexp)
           ("M-0" . sp-forward-slurp-sexp))
    :config
    (show-smartparens-global-mode -1))
#+end_src

Somewhat related, =expand-region= provides two nice tools to either expand or contract the selected region semantically (ie. it understands S-expressions, strings, ..).

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-S-<up>" . er/expand-region)
           ("C-S-<down>" . er/contract-region)))
#+end_src

**** =highlight-parentheses=

Let's use =highlight-parentheses= to always highlight the nearest parentheses. This makes it easier to see where =barf= and =slurp= will apply.

Note that this only highlights =()[]{}= pairs, but not =""''= etc.

#+begin_src emacs-lisp
  ;; Register a custom post-handler so that the highlighted parentheses are updated
  (defun refresh-highlight (id action context)
    (when (member action '(barf-forward
                           barf-backward
                           slurp-forward
                           slurp-backward))
      ;; clear the last point location so that highlight-parentheses will
      ;; re-run the highlight analysis even when the point doesn't move
      (setq highlight-parentheses--last-point 0)))

  (use-package highlight-parentheses
    :after smartparens
    :custom
    (highlight-parentheses-colors '("spring green"))
    :hook
    ((emacs-lisp-mode clojure-mode) . highlight-parentheses-mode)
    :config
    (sp-local-pair 'emacs-lisp-mode "(" nil :post-handlers '(:add refresh-highlight))
    (sp-local-pair 'clojure-mode "(" nil :post-handlers '(:add refresh-highlight))
    (sp-local-pair 'clojure-mode "[" nil :post-handlers '(:add refresh-highlight)))
#+end_src

**** Utilities

#+BEGIN_SRC emacs-lisp
  (defun jet-transit-to-edn ()
    "Run transit->edn conversion on the active buffer."
    (interactive)
    (shell-command-on-region
     (region-beginning)
     (region-end)
     "/home/lassemaatta/bin/jet --pretty --from transit --edn-reader-opts '{:default tagged-literal}'"
     (current-buffer)
     t
     "*jet error buffer*"
     t))

  (defun jet-edn-to-edn ()
    "Format EDN in the active buffer region."
    (interactive)
    (shell-command-on-region
     (region-beginning)
     (region-end)
     "/home/lassemaatta/bin/jet --pretty --from edn --edn-reader-opts '{:default tagged-literal}'"
     (current-buffer)
     t
     "*jet error buffer*"
     t))
#+END_SRC

* Postamble
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
  ;;; settings.el ends here
#+END_SRC
