#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :lexical t
#+STARTUP: showall
* Table of Contents                                            :TOC:noexport:
:PROPERTIES:
:VISIBILITY: folded
:END:
- [[#preamble][Preamble]]
- [[#load-initial-configuration][Load initial configuration]]
  - [[#configuration-flags][Configuration flags]]
  - [[#clear-leader-key][Clear leader key]]
  - [[#disable-gc-while-loading][Disable GC while loading]]
  - [[#bootstrap-use-package][Bootstrap =use-package=]]
  - [[#environment][Environment]]
  - [[#load-optional-local-settings][Load optional local settings]]
  - [[#startup-launchd][Startup (launchd)]]
  - [[#generate-toc][Generate TOC]]
  - [[#shell-commands][Shell commands]]
- [[#general-configuration-for-emacs][General configuration for =emacs=]]
  - [[#keybindings][Keybindings]]
  - [[#quality-of-life][Quality-of-Life]]
  - [[#backups][Backups]]
  - [[#performance][Performance]]
  - [[#mouse--touchpad][Mouse / Touchpad]]
  - [[#whitespace][Whitespace]]
  - [[#help][Help]]
  - [[#file-system-dired][File system (=dired=)]]
  - [[#ui][UI]]
  - [[#fonts][Fonts]]
  - [[#spell-checking][Spell-checking]]
- [[#general-programming][General programming]]
- [[#packages][Packages]]
  - [[#theming-modus-themes][Theming (=modus-themes=)]]
  - [[#utilities][Utilities]]
  - [[#email][Email]]
  - [[#browser-eww][Browser (=eww=)]]
  - [[#project-and-file-management][Project and File Management]]
  - [[#programming][Programming]]
  - [[#terminal][Terminal]]
  - [[#recreational][Recreational]]
- [[#postamble][Postamble]]

* Preamble
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
  ;;; settings.el --- My custom config
  ;;; Commentary:
  ;;; Code:
#+END_SRC
* Load initial configuration
:PROPERTIES:
:VISIBILITY: children
:END:
** Configuration flags

Whether to use =eglot= (and =flymake=) or =lsp-mode= (and =lsp-ui=, =flycheck=).

#+BEGIN_SRC emacs-lisp
  (defconst my-use-eglot t)
#+END_SRC

#+begin_src emacs-lisp
  (defconst my-prefer-lsp-completion-at-point t)
#+end_src

Create a flag to toggle whether we use =evil= or traditional =emacs= bindings.

#+begin_src emacs-lisp
  (defconst use-evil nil)
#+end_src

Check if running on Macos.

#+begin_src emacs-lisp
  (defun my-is-mac-p ()
    "Check if running on macos."
    (eq system-type 'darwin))
#+end_src

Check which Linux distribution are we using.

#+begin_src emacs-lisp
  (defun my-lsb-release ()
    (interactive)
    (unless (my-is-mac-p)
      (string-trim (shell-command-to-string "lsb_release --short --id"))))

  (defconst my-release (my-lsb-release))
#+end_src

** Clear leader key

Let's use =C-f= (or =space=) as the leader key for our commands, but first we must clear its existing command. The =C-c= prefix is already populated with random commands from packages, so this makes it easier to access our own commands.

#+begin_src emacs-lisp
  (defconst my-leader (if use-evil "SPC" (kbd "C-f")))

  (unless use-evil
    (global-unset-key "\C-f"))
#+end_src

** Disable GC while loading

The =early-init.el= disables garbage collection at startup. Here we re-enable it once startup is complete.

#+BEGIN_SRC emacs-lisp
  (add-hook 'elpaca-after-init-hook
            (lambda ()
              (message "Elpaca done!")
              (setq gc-cons-threshold (* 128 1024 1024))))
#+END_SRC

Tip from HN: Run garbage collection when focus moves away from emacs.

#+begin_src emacs-lisp
  (add-function :after
                after-focus-change-function
                (lambda ()
                  (unless (frame-focus-state)
                    (garbage-collect))))
#+end_src

** Bootstrap =use-package=

Always install all packages.

#+BEGIN_SRC emacs-lisp
  (setq use-package-verbose t
        use-package-compute-statistics t
        use-package-always-ensure t
        use-package-always-defer (not (daemonp))
        use-package-always-demand (daemonp))
#+END_SRC

** Environment

Inherit the environment from the shell. This helps with tools like =nvm= or =sdkman=, which manage build tool (=node=, =java=..) versions and add their paths to the shell environment.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :demand t
    :custom
    (exec-path-from-shell-variables '("PATH"
                                      "MANPATH"
                                      "JAVA_HOME"
                                      "TESTCONTAINERS_DOCKER_SOCKET_OVERRIDE"
                                      "DOCKER_HOST"))
    (exec-path-from-shell-arguments '("-l" "-i"))
    :config
    (when (or (display-graphic-p)
              (daemonp))
      (exec-path-from-shell-initialize)))
#+end_src

** Load optional local settings

#+BEGIN_SRC emacs-lisp
  (add-hook 'elpaca-after-init-hook
            (lambda ()
              (when (file-directory-p "~/.emacs.d/init")
                (load "~/.emacs.d/init/init-local.el"))
              (setq custom-file "~/.emacs.d/emacs-custom.el")
              (load custom-file)))
#+END_SRC

** Startup (launchd)

For =launchd= under macos, the following can be placed under =~/Library/LaunchAgents/gnu.emacs.daemon.plist=.

#+begin_src xml :tangle no
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
    <dict>
      <key>Label</key>
      <string>gnu.emacs.daemon</string>
      <key>ProgramArguments</key>
      <array>
        <string>/usr/local/bin/emacs</string>
        <string>--fg-daemon</string>
      </array>
      <key>RunAtLoad</key>
      <true/>
      <key>KeepAlive</key>
      <true/>
      <key>StandardErrorPath</key>
      <string>/tmp/emacs.job.err</string>
      <key>StandardOutPath</key>
      <string>/tmp/emacs.job.out</string>
      <key>ServiceDescription</key>
      <string>Gnu Emacs Daemon</string>
    </dict>
  </plist>
#+end_src

Macos font smoothing can be configured (or disabled) with

#+begin_src bash :tangle no
  defaults write org.gnu.Emacs AppleFontSmoothing -int 0
#+end_src

** Generate TOC

Use [[https://github.com/snosov1/toc-org][toc-org]] to generate a Table of Contents for this document for github.

#+BEGIN_SRC emacs-lisp
  (use-package toc-org
    :after org
    :hook ((org-mode) . toc-org-mode))
#+END_SRC

** Shell commands

The =async-shell-command= allows running arbitrary shell commands. However, the output buffer is writable by default. Let's create a minor mode and some helper functions so that the output buffer
- is automatically selected,
- is made read-only, and
- can be closed with =q=.

#+begin_src emacs-lisp
  (define-minor-mode my-shell-local-mode
    "Minor mode for closing read-only shell buffers with q."
    :init-value nil
    :keymap (let ((map (make-sparse-keymap)))
              (define-key map (kbd "q") 'quit-window)
              map))

  (defun my-process-done (buf-name)
    "Return a sentinel function operating on BUF-NAME."
    (lambda (process signal)
      (when (memq (process-status process) '(exit signal))
        (shell-command-sentinel process signal)
        (let* ((buf (get-buffer buf-name))
               (window (get-buffer-window buf)))
          (select-window window)
          (read-only-mode 1)
          (my-shell-local-mode 1)))))

  (defun my-run-shell-cmd (cmd output-buffer-name error-buffer-name)
    "Wrapper for async-shell-command"
    (interactive)
    (let* ((buf (get-buffer-create output-buffer-name))
           (proc (progn (async-shell-command cmd buf error-buffer-name)
                        (get-buffer-process buf))))
      (if (process-live-p proc)
          (set-process-sentinel proc (my-process-done output-buffer-name))
        (message "No process running :("))))
#+end_src

* General configuration for =emacs=
:PROPERTIES:
:VISIBILITY: children
:END:
** Keybindings

Make it so that emacs can distinguish between =M-8= and =[= when using ergodox.

#+begin_src emacs-lisp
  (defun my-fix-mac-option ()
    (when (my-is-mac-p)
      (setq mac-right-option-modifier nil)))

  (add-hook 'server-after-make-frame-hook 'my-fix-mac-option)
#+end_src

Enable =repeat-mode= by default

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    (repeat-mode +1))
#+end_src

Let's build a tree of commands under our leader key, a bit like how =spacemacs= works. Later packages will add their own keybinding within the tree.

#+begin_src emacs-lisp
  (defun my-init-keys ()
    (my-leader-def
      ""   '(nil :which-key "leader key")
      "q"  '(:ignore t :which-key "Quit")
      "qq" '(save-buffers-kill-emacs :which-key "Quit emacs")
      "qr" '(restart-emacs :which-key "Restart emacs")
      ;; Buffers
      "b"  '(:ignore t :which-key "Buffers")
      "bi" '(ibuffer :which-key "List")
      "bl" '(next-buffer :which-key "Next buffer")
      "bh" '(previous-buffer :which-key "Previous buffer")
      "bk" '(kill-buffer :which-key "Kill buffer")
      "bx" '(kill-buffer-and-window :which-key "Kill buffer, close window")
      "bm" `(,(lambda ()
                (interactive)
                (switch-to-buffer "*Messages*"))
             :which-key "Messages")
      "bs" `(,(lambda ()
                (interactive)
                (find-file (concat user-emacs-directory "settings.org")))
             :which-key "Settings.org")
      ;; Errors
      "e"  '(:ignore t :which-key "Errors")
      ;; Files
      "f"  '(:ignore t :which-key "Files")
      "fs" `(,(lambda ()
                (interactive)
                (save-some-buffers t))
             :which-key "Save all")
      "fS" '(save-buffer :which-key "Save")
      ;; Folding
      "F"  '(:ignore t :which-key "Fold")
      "FF" '(hs-toggle-hiding :which-key "Toggle")
      "Fa" '(hs-show-all :which-key "Show all")
      ;; Git / version control
      "g"  '(:ignore t :which-key "Git / VC")
      "gb" '(magit-blame-addition :which-key "Blame")
      "gn" '(smerge-vc-next-conflict :which-key "Next conflict")
      ;; Help
      "h" '(:ignore t :which-key "Help")
      "hv" '(describe-variable :which-key "Describe variable")
      "hf" '(describe-function :which-key "Describe function")
      "hk" '(describe-key :which-key "Describe key")
      "hb" '(describe-bindings :which-key "Show bindings")
      "hm" '(describe-mode :which-key "Describe mode")
      ;; LSP
      "l"  '(:ignore t :which-key "LSP")
      ;; Notes
      "n"  '(:ignore t :which-key "Notes")
      "na" '(org-agenda :which-key "Agenda")
      "p"  '(:ignore t :which-key "Project")
      ;; Search
      "s"  '(:ignore t :which-key "Search")
      ;; Testing
      "t"  '(:ignore t :which-key "Testing")
      ;; Windows and text/fonts
      "w"  '(:ignore t :which-key "Windows")
      "ww" '(delete-window :which-key "Delete this")
      "wo" '(delete-other-windows :which-key "Delete others")
      "wr" `(,(lambda ()
                (interactive)
                (text-scale-set 0))
             :which-key "Reset text-scale")
      "w S-<right>" '(split-window-right :which-key "Add right")
      "w <right>" '(windmove-right :which-key "Move right")
      "w <up>" '(windmove-up :which-key "Move up")
      "w <left>" '(windmove-left :which-key "Move left")
      "w <down>" '(windmove-down :which-key "Move down")
      ;; Lisp
      "x"  '(:ignore t :which-key "Execute LISP")))
#+end_src

Provide some evaluation shortcuts when working with =elisp= buffers.

#+begin_src emacs-lisp
  (defun my-init-keys-lisp ()
    (my-leader-def
      :keymaps '(emacs-lisp-mode-map org-mode-map)
      "xl" '(eval-last-sexp :which-key "Eval last")
      "xe" '(eval-defun :which-key "Eval defun")))
#+end_src

#+begin_src emacs-lisp
  (use-package general
    :ensure (:wait t)
    :demand t
    :config
    (if use-evil
        (general-create-definer my-leader-def
          :prefix my-leader
          :states '(normal visual))
      (general-create-definer my-leader-def
        :prefix my-leader))
    (my-init-keys)
    (my-init-keys-lisp))
#+end_src

Optionally use =evil= mode for keybindings.

#+begin_src emacs-lisp
  (use-package evil
    :demand t
    :if use-evil
    :init
    (defun my-reset-cursor ()
      (interactive)
      (when (and (boundp 'evil-mode) (not evil-mode))
        (message "reset cursor")
        (setq-default cursor-type 'box)
        (set-cursor-color "#FFFFFF")))
    :hook
    (evil-mode . my-reset-cursor)
    :custom
    (evil-move-beyond-eol t)
    (evil-normal-state-cursor '("green" box))
    (evil-want-keybinding nil)
    (evil-want-C-u-scroll t)
    (evil-mode-line-format '(before . mode-line-front-space))
    :bind
    (:map evil-normal-state-map
          ("<tab>" . evil-indent))
    :config
    (eval-after-load 'undo-tree
      (setq evil-undo-system 'undo-tree))
    (modus-themes-with-colors
      (setq evil-normal-state-tag   (propertize " COMMAND " 'face `((:background ,bg-green-intense :foreground ,fg-main)))
            evil-emacs-state-tag    (propertize "  EMACS  " 'face `((:background ,bg-yellow-subtle :foreground ,fg-dim)))
            evil-insert-state-tag   (propertize " ------- " 'face `((:background ,bg-red-subtle :foreground ,fg-main)))
            evil-replace-state-tag  (propertize " REPLACE " 'face `((:background ,bg-red-intense :foreground ,fg-main)))
            evil-motion-state-tag   (propertize "  MOTION " 'face `((:background ,bg-blue-subtle :foreground ,fg-main)))
            evil-visual-state-tag   (propertize "  VISUAL " 'face `((:background ,bg-cyan-intense :foreground ,fg-main)))
            evil-operator-state-tag (propertize " OPERATE " 'face `((:background ,bg-magenta-intense :foreground ,fg-main)))))
    (evil-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package evil-collection
    :demand t
    :if use-evil
    :after evil
    :config
    (evil-collection-init '(dashboard cider)))
#+end_src

#+begin_src emacs-lisp
  (use-package evil-goggles
    :demand t
    :if use-evil
    :after evil
    :config
    (evil-goggles-mode)
    (evil-goggles-use-diff-faces))
#+end_src

Use [[https://github.com/justbur/emacs-which-key][which-key]] to show suggestions when using keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :demand t
    :ensure nil
    :custom
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-separator " -> ")
    (which-key-idle-delay 0.5)
    (which-key-min-display-lines 6)
    (which-key-add-column-padding 2)
    :config
    (which-key-setup-side-window-bottom)
    (which-key-mode))
#+END_SRC

=hydra= can be used to build custom keybinding menus, a bit like =transient=.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

#+begin_src emacs-lisp
  (use-package major-mode-hydra
    :bind ("M-SPC" . major-mode-hydra)
    :custom
    (major-mode-hydra-invisible-quit-key "q"))
#+end_src

** Quality-of-Life

Don't  require the user to type =yes= or =no= as a simple =y= or =n= is sufficient.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Don't show a GUI dialog when requiring confirmation.

#+begin_src emacs-lisp
  (setq use-dialog-box nil)
#+end_src

Automatically refresh buffers if the file has changed on disk.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    ;; Don't poll if file system already notifies us
    (auto-revert-avoid-polling t)
    (auto-revert-interval 5)
    ;; Check if VC state changes (e.g. branch) even though the file stays the same
    (auto-revert-check-vc-info t)
    :config
    (global-auto-revert-mode t))
#+end_src

Introduce a Clojure -style =comment= macro.

#+begin_src emacs-lisp
  (defmacro comment (&rest sexp) nil)
#+end_src

Start the =*scratch*= in fundamental mode so we don't automatically load all elisp related packages.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (initial-major-mode 'fundamental-mode))
#+end_src

** Backups

#+BEGIN_SRC emacs-lisp
  (setq
   ;; don't clobber symlinks
   backup-by-copying t
   ;; don't litter my fs tree
   backup-directory-alist '(("." . "~/.saves/"))
   auto-save-file-name-transforms `((".*" "~/.saves/" t))
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   ;; use versioned backups
   version-control t)
#+END_SRC

Save command history when we close the frame.

#+begin_src emacs-lisp
  (add-hook 'delete-frame-functions 'recentf-save-list)
  (add-hook 'delete-frame-functions 'savehist-autosave)
#+end_src

** Performance

Increase the default number of bytes to read from subprocesses, as the default is just 4 kB.

#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+END_SRC

The =suggest-key-bindings= feature adds several seconds of delays to various commands when using =M-x=.

#+BEGIN_SRC emacs-lisp
  (setq suggest-key-bindings nil)
#+END_SRC

Enable shortcuts for the internal profiler.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f9>") 'profiler-start)
  (global-set-key (kbd "<f10>") 'profiler-stop)
  (global-set-key (kbd "<f11>") 'profiler-report)
#+END_SRC

Use left-to-right text direction instead of detecting per line, for a minor performance boost.

#+BEGIN_SRC emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)
#+END_SRC

Disable the bidirectional parenthesis algorithm, for a minor performance boost.

#+BEGIN_SRC emacs-lisp
  (setq bidi-inhibit-bpa t)
#+END_SRC

There's a default wait time of =0.1= seconds between emacs and =GTK=.

#+begin_src emacs-lisp
  (setq pgtk-wait-for-event-timeout 0.01)
#+end_src

** Mouse / Touchpad

Check if we're running a graphical session and if so:
- Show a context menu when right clicking

#+begin_src emacs-lisp
  (defun my-when-graphical ()
    (when (display-graphic-p)
      (context-menu-mode)))

  (add-hook 'server-after-make-frame-hook 'my-when-graphical)
#+end_src

*** Scrolling

Set =scroll-margin= to =0= , otherwise the scrolling will jump around when clicking on entries in =treemacs=.

#+BEGIN_SRC emacs-lisp
  (setq auto-window-vscroll nil
        fast-but-imprecise-scrolling t
        scroll-conservatively 101
        scroll-margin 0
        scroll-preserve-screen-position t)
#+END_SRC

Enable smooth scrolling when using macos. However, this cases [[https://def.lakaban.net/2023-03-05-high-quality-scrolling-emacs/][issues]] with text-scaling, where the scale increases dramatically if you press =C= and the touchpad.

#+begin_src emacs-lisp
  (when (my-is-mac-p)
    (pixel-scroll-precision-mode +1)

    (defun my-filter-mwheel-always-coalesce (orig &rest args)
      "A filter function suitable for :around advices that ensures only
     coalesced scroll events reach the advised function."
      (if mwheel-coalesce-scroll-events
          (apply orig args)
        (setq mwheel-coalesce-scroll-events t)))

    (defun my-filter-mwheel-never-coalesce (orig &rest args)
      "A filter function suitable for :around advices that ensures only
     non-coalesced scroll events reach the advised function."
      (if mwheel-coalesce-scroll-events
          (setq mwheel-coalesce-scroll-events nil)
        (apply orig args)))

    ;; Don't coalesce for high precision scrolling
    (advice-add 'pixel-scroll-precision :around #'my-filter-mwheel-never-coalesce)

    ;; Coalesce for default scrolling (which is still used for horizontal scrolling)
    ;; and text scaling (bound to ctrl + mouse wheel by default).
    (advice-add 'mwheel-scroll          :around #'my-filter-mwheel-always-coalesce)
    (advice-add 'mouse-wheel-text-scale :around #'my-filter-mwheel-always-coalesce))
#+end_src

** Whitespace

Highlight trailing whitespace (when not in read-only buffers) and don't use tabs for indenting.

#+BEGIN_SRC emacs-lisp
  (defun show-trailing-if-writeable ()
    (let ((enabled (if buffer-read-only nil t)))
      (setq-local show-trailing-whitespace enabled)
      (setq-local indicate-empty-lines enabled)))

  (add-hook 'text-mode-hook 'show-trailing-if-writeable)
  (add-hook 'prog-mode-hook 'show-trailing-if-writeable)
  (add-hook 'read-only-mode-hook 'show-trailing-if-writeable)

  (setq-default indent-tabs-mode nil)
#+END_SRC

Highlight any tabs as if they were trailing whitespace. Again, only in writable buffers.

#+BEGIN_SRC emacs-lisp
  (add-hook 'font-lock-mode-hook
            (lambda ()
              (when (not buffer-read-only)
                (font-lock-add-keywords
                 nil
                 '(("\t" 0 'trailing-whitespace prepend))))))
#+END_SRC

Cleanup trailing whitespace when saving a buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Highlight any glyph-less characters (zero-width spaces etc.) in red.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :demand t
    :hook ((text-mode
            prog-mode) . glyphless-display-mode)
    :config
    (set-face-background 'glyphless-char "red"))
#+end_src

Some archaic writing styles expect two spaces between sentences.

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

Use =shrink-whitespace= to remove whitespace around the point.

#+begin_src emacs-lisp
  (use-package shrink-whitespace
    :bind (("C-S-k" . shrink-whitespace)))
#+end_src

** Help

[[https://github.com/Wilfred/helpful][helpful]] provides some additional information in help buffers, such as keymaps or call locations.

#+begin_src emacs-lisp
  (use-package helpful
    :general
    (my-leader-def
      :keymaps 'emacs-lisp-mode-map
      "hh" '(helpful-at-point :which-key "Thing-at-point"))
    :bind
    (([remap describe-key]      . helpful-key)
     ([remap describe-command]  . helpful-command)
     ([remap describe-variable] . helpful-variable)
     ([remap describe-function] . helpful-callable)))
#+end_src

=eldoc= is the built-in documentation tool, which can show documentation in e.g. the echo area or a dedicated buffer.

#+begin_src emacs-lisp
  (use-package eldoc
    :demand t
    :ensure nil
    :custom
    (eldoc-documentation-strategy 'eldoc-documentation-compose))
#+end_src

[[https://github.com/casouri/eldoc-box][eldoc-box]] can display =eldoc= documentation in a nice popup child-frame.

#+begin_src emacs-lisp
  (use-package eldoc-box
    :after eldoc
    :general
    (my-leader-def
      :keymaps '(clojure-mode-map)
      "hh" '(eldoc-box-help-at-point :which-key "Glance docs")))
#+end_src

Let's define some helper functions, which can be used to wrap the various =eldoc= display functions (like =eldoc-display-in-echo-area= or =eldoc-display-in-buffer=). These functions allow us to choose which documentation (e.g. function signatures, flymake errors, LSP documentation) appears in which output. Note that these only work with =emacs= 30.x as the =:origin= is a new feature.

#+begin_src emacs-lisp
  (defun my-filter-by-source (display-fn &rest source-fns)
    "Wrap DISPLAY-FN such that only docs from SOURCE-FNS are shown."
    (lambda (docs interactive)
      (let ((docs (->> docs
                       (-filter (lambda (doc)
                                  (let* ((plist (cdr doc))
                                         (origin (plist-get plist :origin)))
                                    (-contains? source-fns origin)))))))
        (funcall display-fn docs interactive))))

  (defun my-remove-by-source (display-fn &rest source-fns)
    "Wrap DISPLAY-FN such that any docs from SOURCE-FNS are ignored."
    (lambda (docs interactive)
      (let ((docs (->> docs
                       (-remove (lambda (doc)
                                  (let* ((plist (cdr doc))
                                         (origin (plist-get plist :origin)))
                                    (-contains? source-fns origin)))))))
        (funcall display-fn docs interactive))))
#+end_src

** File system (=dired=)

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :general
    (:keymaps 'dired-mode-map
     "<C-up>" 'dired-up-directory))
#+end_src

Re-use the same buffer when navigating to subdirectories in =dired=.

#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

Show some nice icons in =dired= buffers.

#+begin_src emacs-lisp
  (use-package nerd-icons-dired
    :demand t
    :after (nerd-icons)
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

Use =C-s= to filter entries in a =dired= buffer.

#+begin_src emacs-lisp
  (use-package dired-narrow
    :bind (:map dired-mode-map
           ("C-s" . dired-narrow)))
#+end_src

Use =?= to open a nice =transient= menu in =dired=.

#+begin_src emacs-lisp
  (use-package casual-dired
    :after dired
    :general
    (:keymaps 'dired-mode-map
              "?" 'casual-dired-tmenu))
#+end_src

** UI

Hide the default splash screen.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

Highlight the current line.

#+begin_src emacs-lips
  (global-hl-line-mode)
#+end_src

Use =ace-window= to quickly move between windows.

TODO : We might want to move this under the leader key.

#+begin_src emacs-lisp
  (use-package ace-window
    :bind (("C-p" . ace-window))
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (aw-dispatch-always t)
    (aw-ignore-on nil))
#+end_src

Show the whole file path in the window title

#+begin_src emacs-lisp
  (setq frame-title-format
        `((buffer-file-name "%f" "%b")
          ,(format " - GNU Emacs %s" emacs-version)))
#+end_src

** Fonts

Detect the active monitor name and update the font size accordingly.

#+begin_src emacs-lisp
  (defvar font-family "Hack Nerd Font Mono")
  (defvar font-family-variable "Georgia")

  (set-face-attribute 'default nil :family font-family)

  ;; Using a floating point height implies relative scaling wrt. the 'default font height
  (set-face-attribute 'fixed-pitch nil :family font-family :height 1.0)
  (set-face-attribute 'variable-pitch nil :family font-family-variable :height 1.0)
  (set-face-attribute 'mode-line nil :family font-family :height 1.0)

  ;; Not sure if this actually does anything
  (when (my-is-mac-p)
    (setq ns-use-thin-smoothing t))

  (defun my-update-font-size (font-height)
    "Update the font DPI to FONT-HEIGHT."
    (set-face-attribute 'default nil :height font-height))

  (defun my-monitor-name ()
    "Return the name of the current monitor as string."
    (interactive)
    (frame-monitor-attribute 'name))

  (defun my-monitor-attrs-to-font-height ()
    "Use screen resolution and physical size to determine font size."
    (let-alist (frame-monitor-attributes)
      (let ((x (nth 2 .geometry))
            (y (nth 3 .geometry))
            (w (nth 0 .mm-size))
            (h (nth 1 .mm-size)))
        (message "%sx%s px, %s mm x %s mm" x y w h)
        (cond
         ;; M1 main screen
         ((and (eq w 344) (eq h 222)) 140)
         ;; M28U with apple
         ((and (eq x 2560) (eq y 1440)
               (eq w 631) (eq h 360))  140)
         ((and (eq x 3008) (eq y 1692)
               (eq w 628) (eq h 359))  150)
         ;; x270 @ 1080p
         ((and (eq x 1920) (eq y 1080)
               (eq w 280) (eq h 160)) 130)
         ;; p14s @ 1080p
         ((and (eq x 1920) (eq y 1080)
               (eq w 310) (eq h 170)) 70)
         ;; P27h-20 @ 1440p
         ((and (eq x 2560) (eq y 1440)
               (eq w 600) (eq h 340)) 80)
         ((and (eq x 2560) (eq y 1440)
               (eq w 602) (eq h 338)) 190)
         ;; WSL @ 4k
         ((and (eq x 3840) (eq y 2160)
               (eq w 0) (eq h 0)) 140)
         ;; M28U @ 4k
         ((and (eq x 3840) (eq y 2160)
               (eq w 630) (eq h 360)) 90)))))

  (defun my-monitor-to-font-height ()
    "Map monitor name to font height."
    (or (my-monitor-attrs-to-font-height)
        (pcase (my-monitor-name)
          ("M28U/22060B001950" 90)
          ("eDP-1-unknown" 130)
          ((pred (string-prefix-p "P27h-20/V906XFMC")) 110)
          (name (progn
                  (message "Unknown monitor '%s'" name)
                  100)))))

  (defun my-refresh-dpi ()
    "Update the font size based on the active monitor."
    (interactive)
    (let* ((font-height (my-monitor-to-font-height)))
      (message (format "Set font height: %s" font-height))
      (my-update-font-size font-height)))

  (defun my-refresh-dpi-delayed ()
    "Refresh DPI after a small delay"
    (run-at-time "0.2 sec" nil #'my-refresh-dpi))

  ;; Refresh DPI after creating a frame
  (add-hook 'server-after-make-frame-hook 'my-refresh-dpi-delayed)

  ;; Immediately refresh if not using emacsclient
  (when (and (not (daemonp))
             (display-graphic-p))
    (my-refresh-dpi))
#+end_src

Don't use variable pitch fonts in =shr= / =eww=.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (shr-use-fonts nil))
#+end_src

** Spell-checking

[[https://github.com/minad/jinx][jinx]] is a new spell-checker which uses various spell-checking engines through [[https://abiword.github.io/enchant/][enchant]].

#+begin_src emacs-lisp
  (use-package jinx
    :hook ((prog-mode text-mode) . jinx-mode)
    :general
    (my-leader-def
      :keymaps 'jinx-mode-map
      "et" '(jinx-correct :which-key "Correct mispelled")
      "em" '(jinx-next :which-key "Next mispelled"))
    :custom
    (jinx-languages "en fi")
    :custom-face
    (jinx-misspelled ((((supports :underline (:style wave))) :underline (:style wave :color "#feacd0"))
                      (t :underline t :inherit error))))
#+end_src

* General programming
:PROPERTIES:
:VISIBILITY: folded
:END:

Show line numbers.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook (lambda ()
                              (when (not (member major-mode '(org-mode)))
                                (display-line-numbers-mode))))
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

Highlight matching parenthesis.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

Enable /HideShow/ mode: allows collapsing s-exprs (=<backtab>=  is =S-<tab>=).

#+begin_src emacs-lisp
  (use-package hideshow
    :ensure nil
    :hook ((clojure-mode . hs-minor-mode)
           (emacs-lisp-mode . hs-minor-mode)
           (lisp-mode . hs-minor-mode))
    :bind (("<backtab>" . hs-toggle-hiding)))
#+END_src

Indent current function

#+begin_src emacs-lisp
  (defun my-indent-defun ()
    "Indent the current defun."
    (interactive)
    (save-excursion
      (mark-defun)
      (indent-region (region-beginning) (region-end))))

  (global-set-key (kbd "C-<tab>") #'my-indent-defun)
#+end_src

Emacs uses coarse regexp based parsers for syntax highlighting. Since emacs 29+, the internal =treesit= package provides language-specific parsers, which are both faster and provide more accurate results.

However, not all languages are yet supported and =treesit= does not automatically use the =-ts=  modes. =treesit-auto= will both a) download the necessary grammars and b) active the proper =-ts= mode when available.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :config
    (global-treesit-auto-mode))
#+end_src

* Packages
** Theming (=modus-themes=)
:PROPERTIES:
:VISIBILITY: folded
:END:

Provide icons for stuff like =treemacs=.

#+BEGIN_SRC emacs-lisp
  (use-package nerd-icons
    :demand t)
#+END_SRC

Provide icons for =ibuffer=.

#+begin_src emacs-lisp
  (use-package nerd-icons-ibuffer
    :demand t
    :after nerd-icons
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

Construct a simple mode line.

#+BEGIN_SRC emacs-lisp
  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-frame-identification
                  " "
                  mode-line-buffer-identification
                  (vc-mode vc-mode)
                  " "
                  mode-name
                  (flymake-mode flymake-mode-line-format)
                  (flycheck-mode flycheck-mode-line)
                  " "
                  mode-line-misc-info
                  " "
                  mode-line-process
                  " "
                  (cider-mode cider-mode-line)
                  " "
                  mode-line-end-spaces))
#+END_SRC

Use =modus-vivendi= as the main theme.

#+BEGIN_SRC emacs-lisp
  (use-package modus-themes
    :demand t
    :custom
    (modus-themes-custom-auto-reload t)
    (modus-themes-org-blocks 'gray-background)
    (modus-themes-mixed-fonts nil)
    (modus-vivendi-palette-overrides
     '((bg-hl-line bg-magenta-subtle)))
    :config
    (add-hook 'modus-themes-after-load-theme-hook #'my-tune-colors)
    (if (daemonp)
        (add-hook 'server-after-make-frame-hook
                  (defun my-init-theme-fn ()
                    (modus-themes-load-theme 'modus-vivendi)
                    (select-frame-set-input-focus (selected-frame))))
      (modus-themes-load-theme 'modus-vivendi))
    :init
    (defun my-tune-colors ()
      (interactive)
      (set-face-background 'highlight "#004065")
      (modus-themes-with-colors
        (custom-set-faces
         `(org-block-begin-line ((,c :inherit modus-themes-fixed-pitch
                                     :foreground "gray65"
                                     :background ,bg-main)))))))
#+END_SRC

#+begin_src emacs-lisp
  (use-package spacious-padding
    :demand t
    :if (or (display-graphic-p)
            (daemonp))
    :config
    (defun my-spacing ()
      (spacious-padding-mode 1))
    (add-hook 'emacs-startup-hook 'my-spacing))
#+end_src

** Utilities
:PROPERTIES:
:VISIBILITY: children
:END:
*** Minibuffer completion (=vertico=)

Hide commands in =M-x= which do not apply to the current mode.

#+BEGIN_SRC emacs-lisp
  (setq read-extended-command-predicate #'command-completion-default-include-p)
#+END_SRC

[[https://github.com/minad/vertico][vertico]] provides completion for minibuffer commands.

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :demand t
    :ensure (:files (:defaults "extensions/*"))
    :init
    (vertico-mode)
    (vertico-multiform-mode)
    :custom
    (vertico-sort-function #'vertico-sort-history-alpha)
    (vertico-multiform-commands '((consult-imenu buffer)))
    (vertico-multiform-categories '((consult-grep buffer))))
#+END_SRC

The =vertico-directory= extension enhances the directory navigation when completing.

#+begin_src emacs-lisp
  (use-package vertico-directory
    :after vertico
    :ensure nil
    ;; More convenient directory navigation commands
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    ;; Tidy shadowed file names
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

[[https://github.com/oantolin/orderless][orderless]] provides /completion style/ (ie. fuzzy searching) for command completion.

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :demand t
    :after vertico
    :custom
    (completion-styles '(basic orderless partial-completion))
    (completion-category-defaults nil)
    :config
    (add-to-list 'completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

[[https://github.com/minad/cape][cape]] provides extensions and utilities to =completion-at-point-functions=.

#+BEGIN_SRC emacs-lisp
  (use-package cape
    :demand t
    :after vertico
    :config
    (add-hook 'completion-at-point-functions #'cape-file))
#+END_SRC

The [[https://github.com/minad/marginalia][marginalia]] package provides description of entries (e.g. files, commands) in completion menus.

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :demand t
    :after (vertico)
    :init
    (marginalia-mode))
#+END_SRC

Provide icons for completion menus (e.g. when selecting which file to open etc.).

#+BEGIN_SRC emacs-lisp
  (use-package nerd-icons-completion
    :demand t
    :after (nerd-icons marginalia)
    :config
    (nerd-icons-completion-marginalia-setup))
#+END_SRC

The [[https://github.com/minad/consult][consult]] package provides a bunch of utility functions related to completions (e.g. switch buffer, search within buffer..).

The =consult-narrow-key= (=<=) can be pressed to display the narrowing categories (e.g. =f= for =files=).

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :demand t
    :after (projectile)
    :general
    (my-leader-def
      "bb" '(consult-buffer :which-key "Switch buffer")
      "ss" '(consult-line :which-key "Search (in buffer)")
      "sr" '(consult-ripgrep :which-key "Search (ripgrep)")
      "si" '(consult-imenu :which-key "Imenu"))
    :bind (("C-s" . consult-line)
           ("C-x b" . consult-buffer)
           ("C-M-y" . consult-yank-from-kill-ring))
    :custom
    (consult-narrow-key "<")
    (consult-project-function (lambda (_)
                                (projectile-project-root)))
    :config
    (with-eval-after-load 'xref
      (setq xref-show-xrefs-function #'consult-xref)
      (setq xref-show-definitions-function #'consult-xref))
    (require 'consult-imenu)
    (add-to-list 'consult-imenu-config
                 '(clojure-mode :toplevel "Functions"
                                :types ((?f "Functions"  font-lock-function-name-face)
                                        (?m "Macros"     font-lock-function-name-face)
                                        (?n "Namespaces" font-lock-constant-face)
                                        (?i "Interfaces" font-lock-type-face)
                                        (?v "Variables"  font-lock-variable-name-face)))))
#+END_SRC

#+begin_src emacs-lisp
  (use-package consult-projectile
    :demand t
    :after (consult projectile)
    :general
    (my-leader-def
      :keymaps 'projectile-mode-map
      "bp" '(consult-projectile :which-key "Project buffers")
      "pf" '(consult-projectile-find-file :which-key "Find file"))
    :config
    (substitute-key-definition 'projectile-find-file
                               'consult-projectile
                               projectile-command-map))
#+end_src

The [[https://github.com/oantolin/embark][embark]] package provides a way to run commands against the currently active minibuffer target (e.g. =C-x C-f= to browse files, then =C-ä= to choose an action on a file).

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :after (vertico)
    :bind (("C-ä" . embark-act)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :demand t
    :after (embark consult))
#+END_SRC

Use =savehist= to save minibuffer command history between sessions.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))
#+END_SRC

Close the minibuffer if you click on a buffer.

#+begin_src emacs-lisp
  (defun stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))

  (add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)
#+end_src

*** Search

[[https://github.com/dajva/rg.el][rg]] provides [[https://github.com/BurntSushi/ripgrep][ripgrep]] searching within =emacs=.

Let's use =display-buffer-alist= to select the =*rg*= buffer automatically ([[https://www.reddit.com/r/emacs/comments/un283d/comment/i8pxp4k/][link]]).

#+BEGIN_SRC emacs-lisp
  (use-package rg
    :general
    (my-leader-def
      "sm" '(rg-menu :which-key "Search menu"))
    :config
    ;; Focus on search results immediately
    (add-to-list
     'display-buffer-alist
     '("\\*rg\\*" . (nil . ((body-function . select-window)))))

    ;; Add some custom search shortcuts
    (rg-define-search clojure-project
      :query ask
      :format literal
      :dir project
      :files "*.{cljc,cljs,clj}"
      :menu ("Custom" "c" "Clojure")))
#+END_SRC

*** Org mode (=org=, =polymode=)

#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :defer 1
    :general
    (my-leader-def
      :keymaps 'org-mode-map
      :major-modes t
      "m" '(:ignore t :which-key "Org Mode")
      "mi" 'org-insert-structure-template
      "me" 'org-edit-special
      "mc" '(:ignore t :which-key "orc-clock")
      "mci" 'org-clock-in
      "mco" 'org-clock-out
      "mcd" 'org-clock-display
      "mcg" 'org-clock-goto)
    (my-leader-def
      :keymaps 'org-src-mode-map
      :predicate 'org-src-mode
      "m"  '(:ignore t :which-key "Org special buffer")
      "mq" '(org-edit-src-exit :which-key "Quit"))
    :custom
    (org-modules '(ol-w3m ol-bibtex ol-docview ol-gnus ol-info ol-eww
                          ol-man org-habit))
    ;; Enable syntax highlighting when exporting as PDFs. Requires the =minted= package for LaTeX.
    (org-latex-listings 'minted)
    (org-latex-pdf-process
     '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (org-babel-default-header-args:emacs-lisp ((:lexical . t)))
    (org-babel-clojure-backend 'cider)
    (org-babel-clojure-sync-nrepl-timeout nil)
    (org-clock-persist t)
    (org-habit-preceding-days 7)
    (org-habit-following-days 14)
    (org-todo-keywords '((sequence "TODO(t!)" "|" "DONE(d@)" "CANCELLED(c@)")))
    (org-todo-keyword-faces '(("CANCELLED" . (face-attribute 'modus-themes-fg-yellow :foreground))))
    (org-plantuml-jar-path (expand-file-name "/usr/share/java/plantuml/plantuml.jar"))
    ;; Show clocked in time for today in mode line (not total hours)
    (org-clock-mode-line-total 'today)
    :mode ("\\.org\\'" . org-mode)
    :hook ((org-mode . visual-line-mode)
           (org-babel-after-execute . org-redisplay-inline-images))
    :config
    (defun my-add-agenda (directory)
      (when (file-directory-p directory)
        (setq org-agenda-files (add-to-list 'org-agenda-files directory))))
    (my-add-agenda "~/Dropbox/org/")
    (my-add-agenda "~/org-local/")
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-clock-persistence-insinuate)
    (add-hook 'elpaca-after-init-hook
              (lambda ()
                (org-babel-do-load-languages
                 'org-babel-load-languages
                 '((clojure . t)
                   (emacs-lisp . t)
                   (http . t)
                   (dot . t)
                   (shell . t)
                   (plantuml . t)))))
    ;; Eagerly load modules, before opening a org buffer
    (org-load-modules-maybe))
#+end_src

#+begin_src emacs-lisp
  (use-package org-modern
    :after org
    :hook ((org-mode . org-modern-mode))
    :custom
    (org-modern-label-border 1) ; smaller border around labels
    :config
    ;; Iosevka has more symbols (ie. arrows) for section headers
    (set-face-attribute 'org-modern-symbol nil :family "Iosevka"))
#+end_src

=ob-http= allows making HTTP requests in org mode source blocks with ~begin_src http~.

#+begin_src emacs-lisp
  (use-package ob-http
    :after org
    :demand t)
#+end_src

#+begin_src emacs-lisp
  (use-package plantuml-mode)
#+end_src

=ox-gfm= allows exporting org mode documents as /GitHub flavored Markdown/.

#+begin_src emacs-lisp
  (use-package ox-gfm
    :after org
    :demand t)
#+end_src

As =org-hide-emphasis-markers= hides the styling, we can use =org-appear= to undo that when the point enters a styled word. The =org-appear-autolinks= does the same to links.

#+begin_src emacs-lisp
  (use-package org-appear
    :after org
    :hook ((org-mode . org-appear-mode))
    :custom
    (org-hide-emphasis-markers t)
    (org-appear-autolinks t))
#+end_src

=visual-fill-column= allows wrapping (and centering) text at a given width.

#+begin_src emacs-lisp
  (use-package visual-fill-column
    :custom
    (visual-fill-column-width 140)
    (visual-fill-column-center-text t))
#+end_src

=polymode= offers /multiple major modes/ inside a single buffer.

Disable LSP within a nested block as it causes the point to jump around (see [[https://github.com/polymode/polymode/issues/316][bug]]).

#+begin_src emacs-lisp
  (use-package polymode
    :disabled t
    :config
    (setq-default polymode-lsp-integration nil))

  (use-package poly-org
    :defer t
    :disabled t
    :after polymode)

  (defun load-polymode()
    (interactive)
    (require 'polymode)
    (poly-org-mode +1))
#+end_src

*** Note keeping (=org-roam=)

Use [[https://www.orgroam.com/][org-roam]] for note keeping and time tracking.

#+begin_src emacs-lisp
  (use-package emacsql
    :demand t)

  (use-package emacsql-sqlite
    :demand t
    :after emacsql)
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :after (org emacsql-sqlite)
    :general
    (my-leader-def
      "nf" '(org-roam-node-find :which-key "Find note")
      "ni" '(org-roam-node-insert :which-key "Insert note"))
    :custom
    (org-roam-directory "~/org-roam")
    :config
    (org-roam-db-autosync-mode))
#+END_SRC

*** Better undo (=undo-tree=)

[[https://gitlab.com/tsc25/undo-tree][undo-tree]] provides a nice tree-view of the undo history.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :demand t
    :custom
    (undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
    (undo-tree-auto-save-history nil)
    :config
    (global-undo-tree-mode))
#+END_SRC

*** Gumshoe

[[https://github.com/Overdr0ne/gumshoe][gumshoe]] keeps track of the point position over time and allows us to navigate back / forward in history where we last were.

#+begin_src emacs-lisp
  (use-package gumshoe
    :disabled
    :demand t
    :init
    (global-gumshoe-mode +1)
    :custom
    (gumshoe-slot-schema '(buffer position line))
    (gumshoe-prefer-same-window t)
    (gumshoe-peruse-separator " ")
    (gumshoe-show-footprints-p nil)
    :general
    (:keymaps 'global-gumshoe-backtracking-mode-map
     "<left>" '(global-gumshoe-backtracking-mode-back :which-key "Back")
     "<right>" '(global-gumshoe-backtracking-mode-forward :which-key "Forward"))
    (my-leader-def
      "C-<left>" '(gumshoe-peruse-globally :which-key "Show history")
      "<left>" '(gumshoe-backtrack :which-key "Back")))
#+end_src

*** Avy

Use =avy= to quickly jump to a location. You can also use the sequence =C-j <search string> ?= to bring up other actions besides jumping.

#+begin_src emacs-lisp
  (use-package avy
    :demand t
    :config
    (bind-key* "C-j" 'avy-goto-char-timer)
    :custom
    (avy-timeout-seconds 0.2))
#+end_src

** Email
:PROPERTIES:
:VISIBILITY: folded
:END:

We use =mbsync=, which is usually incorporated in the =isync= package, to fetch emails. Once fetched, we can use =mu= to index them for efficient searching. =mu= also provides =mu4e=; the emacs GUI for =mu=.

Manually run =mbsync= with

#+begin_src bash :tangle no
  mbsync --config .config/mbsyncrc -a
#+end_src

Init =mu= indexing with something like

#+begin_src bash  :tangle no
  mu init --maildir=/home/lassemaatta/mail --my-address=lasse.olavi.maatta@gmail.com
#+end_src

and run it with

#+begin_src bash :tangle no
  mu index
#+end_src

#+begin_src emacs-lisp
  (use-package mu4e
    :disabled t
    :ensure nil
    ;; On Linux
    :load-path "/usr/share/emacs/site-lisp/mu4e"
    ;; On macos / macports
    :load-path "/opt/local/share/emacs/site-lisp/mu4e"
    :after org
    :commands (mu4e)
    :custom
    (mu4e-get-mail-command "mbsync --config ~/.config/mbsyncrc -a")
    (mu4e-change-filenames-when-moving t)
    (mu4e-confirm-quit nil)
    (mu4e-context-policy 'pick-first)
    :config
    (with-eval-after-load "mm-decode"
      (add-to-list 'mm-discouraged-alternatives "text/html")
      (add-to-list 'mm-discouraged-alternatives "text/richtext"))
    (setq mu4e-maildir-shortcuts
          '(("/gmail/Inbox"             . ?i)
            ("/gmail/[Gmail]/Sent Mail" . ?s)
            ("/gmail/[Gmail]/Trash"     . ?t)
            ("/gmail/[Gmail]/Drafts"    . ?d)
            ("/gmail/[Gmail]/All Mail"  . ?a)))
    (setq mu4e-contexts
          (list
           (make-mu4e-context
            :name "Home"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address . "lasse.olavi.maatta@gmail.com")
                    (user-full-name    . "Lasse Määttä")
                    (mu4e-drafts-folder  . "/gmail/[Gmail]/Drafts")
                    (mu4e-sent-folder  . "/gmail/[Gmail]/Sent Mail")
                    (mu4e-refile-folder  . "/gmail/[Gmail]/All Mail")
                    (mu4e-trash-folder  . "/gmail/[Gmail]/Bin"))))))
#+end_src

** Browser (=eww=)
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :after major-mode-hydra
    :config
    (major-mode-hydra-define eww-mode nil
      ("Navigate"
       (("n" shr-next-link "Next link" :exit nil)
        ("p" shr-previous-link "Previous link" :exit nil))
       "Tools"
       (("&" eww-browse-with-external-browser "Open browser")))))
#+end_src

** Project and File Management
:PROPERTIES:
:VISIBILITY: children
:END:
*** Startup Dashboard (=dashboard=)

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] shows a list of recent projects and files when opening =emacs=.

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :demand t
    :if (or (display-graphic-p)
            (daemonp))
    :after (projectile org)
    :custom
    (dashboard-center-content t)
    (dashboard-set-heading-icons t)
    (dashboard-projects-backend 'projectile)
    (dashboard-agenda-release-buffers t)
    (dashboard-agenda-prefix-format " %i %s ")
    (dashboard-items '((agenda . 5)
                       (bookmarks . 5)
                       (projects . 5)
                       (recents . 10)))
    :config
    ;; Refresh the dashboard once to refresh fonts etc.
    (defun my-refresh-dashboard ()
      (when (string= dashboard-buffer-name (buffer-name))
        (dashboard-refresh-buffer))
      (remove-hook 'focus-in-hook #'my-refresh-dashboard))
    (add-hook 'focus-in-hook #'my-refresh-dashboard)
    (dashboard-setup-startup-hook))
#+END_SRC

*** File Explorer (=treemacs=)

[[https://github.com/Alexander-Miller/treemacs][treemacs]] offers a Eclipse-like project explorer.

Note that we exclude some build directories so that changes in files don't propagate to =treemacs=.

#+BEGIN_SRC emacs-lisp
  ;; treemacs seems to depend on pfuture but not always install it..
  (use-package pfuture)

  (use-package treemacs
    :bind (("<f1>" . treemacs)
           ("<f5>" . treemacs-find-file))
    :custom
    (treemacs-space-between-root-nodes nil)
    (treemacs-expand-after-init nil)
    (treemacs-no-png-images (not my-use-eglot))
    :config
    (define-key treemacs-mode-map [drag-mouse-1] nil)
    (treemacs-follow-mode -1)
    (defun treemacs-ignore (filename absolute-path)
      (or (cl-search "/.shadow-cljs" absolute-path)
          (cl-search "/.idea" absolute-path)
          (cl-search "/target" absolute-path)
          (cl-search "/node_modules" absolute-path)))
    (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore))

  (use-package treemacs-nerd-icons
    :demand t
    :after (treemacs nerd-icons)
    :config
    (treemacs-load-theme "nerd-icons"))
#+END_SRC

#+begin_src emacs-lisp
  (use-package treemacs-mu4e
    :ensure (:host github :repo "Alexander-Miller/treemacs" :files ("src/extra/treemacs-mu4e.el"))
    :after (treemacs mu4e)
    :general
    (my-leader-def
      :keymaps 'mu4e-main-mode-map
      "<f1>" '(treemacs-mu4e :which-key "Show mu4e folders")))
#+end_src

*** Project Management (=projectile=)

[[https://github.com/bbatsov/projectile][projectile]] is used for managing projects.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :after (vertico)
    :general
    (my-leader-def
      :keymaps 'projectile-mode-map
      "ti" '(projectile-toggle-between-implementation-and-test :which-key "Toggle impl/test"))
    (:keymaps 'projectile-mode-map
      "C-c p" 'projectile-command-map)
    :custom
    (projectile-mode-line-prefix "")
    (projectile-completion-system 'default)
    (projectile-project-search-path '("~/work/" "~/personal/"))
    (projectile-switch-project-action #'projectile-find-file)
    (projectile-enable-caching t)
    :init
    (projectile-mode +1)
    :config
    (defun my-projectile-common-lisp-project-p (&optional DIR)
      (or (projectile-verify-file-wildcard "?*.asd")
          (projectile-verify-file-wildcard "?*.asdf")))
    (projectile-register-project-type 'common-lisp #'my-projectile-common-lisp-project-p
                                      :project-file '("?*.asd" "?*.asdf"))
    (defun my-projectile-reset-cache (&rest _args)
      (message "Resetting projectile cache")
      (projectile-invalidate-cache nil))
    (eval-after-load 'magit
      (progn
        (advice-add 'magit-checkout :after #'my-projectile-reset-cache)
        (advice-add 'magit-branch-and-checkout :after #'my-projectile-reset-cache))))
#+END_SRC

Enable processing of ANSI color codes when running e.g. tests with =projectile-test-project=.

#+begin_src emacs-lisp
  (use-package ansi-color
    :ensure nil
    :hook (compilation-filter . ansi-color-compilation-filter))
#+end_src

Integration with [[https://github.com/Alexander-Miller/treemacs][treemacs]].

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-projectile
    :after (treemacs projectile)
    :demand t)
#+END_SRC

Use [[https://github.com/nex3/perspective-el][perspective]] to create perspectives for each open project.

#+begin_src emacs-lisp
  (use-package perspective
    :demand t
    :after (consult)
    :bind
    (([remap kill-buffer] . persp-kill-buffer*))
    :general
    (my-leader-def
      :keymaps 'persp-mode-map
      "pg" '(persp-set-buffer :which-key "Grab buffer to persp")
      "ps" '(persp-switch :which-key "Switch persp")
      "pr" '(persp-remove-buffer :which-key "Remove buffer from persp")
      "pn" '(persp-next :which-key "Next perspective")
      "pp" '(persp-prev :which-key "Previous perspective")
      "pk" '(persp-kill :which-key "Kill perspective"))
    :custom
    (persp-mode-prefix-key (kbd "C-c r"))
    (persp-purge-initial-persp-on-save t)
    (persp-state-default-file (concat user-emacs-directory "persp.state"))
    :config
    ;; Use perspective as a buffer source for consult when switching buffers
    (consult-customize consult--source-buffer :hidden t :default nil)
    (add-to-list 'consult-buffer-sources persp-consult-source)
    (persp-mode +1))
#+end_src

Integrate =perspective= with =projectile= such that opening a new project will create a perspective for it.

#+begin_src emacs-lisp
  (use-package persp-projectile
    :after (projectile perspective)
    :demand t
    :general
    (my-leader-def
      :keymaps 'projectile-mode-map
      "po" '(projectile-persp-switch-project :which-key "Open project")))
#+end_src

Only show current perspective / project in =treemacs=.

#+begin_src emacs-lisp
  (use-package treemacs-perspective
    :after (treemacs perspective)
    :demand t
    :config
    (treemacs-set-scope-type 'Perspectives))
#+end_src

The [[https://sr.ht/~woozong/perspective-tabs/][perspective-tabs]] package allows us to display open perspectives in =emacs= tabs.

#+begin_src emacs-lisp
  (use-package perspective-tabs
    :ensure (:host sourcehut :repo "woozong/perspective-tabs")
    :after (perspective)
    :demand t
    :init
    (perspective-tabs-mode +1))
#+end_src

*** Git (=magit=, =forge=)

[[https://magit.vc/][magit]] provides a really nice =git= UI.

#+begin_src emacs-lisp
  (use-package transient)
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :after transient
    :custom
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (magit-bury-buffer-function #'magit-restore-window-configuration)
    (magit-diff-refine-hunk 'all)
    (magit-blame-styles
     '((headings
        (heading-format . "%-20a %C %s\n"))
       (margin
        (margin-format    . ("%s%f" " %C %a" " %H"))
        (margin-width     . 42)
        (margin-face      . magit-blame-margin)
        (margin-body-face . (magit-blame-dimmed)))
       (highlight
        (highlight-face . magit-blame-highlight))
       (lines
        (show-lines . t)
        (show-message . t))))
    :commands (magit-status)
    :config
    ;; Don't calculate tags in magit status window
    (remove-hook 'magit-status-headers-hook #'magit-insert-tags-header)
    (magit-add-section-hook 'magit-status-sections-hook
                            'magit-insert-unpushed-to-upstream
                            'magit-insert-unpushed-to-upstream-or-recent
                            'replace)
    (when (my-is-mac-p)
      (setq magit-git-executable "/opt/local/bin/git")))
#+END_SRC

Use =treemacs-magit= to update the =treemacs= view when =magit= updates the =git= repository state.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs-magit
    :demand t
    :after (magit treemacs))
#+END_SRC

=forge= adds support for viewing and manipulating pull requests to =magit=.

Remap =magit-visit-thing= from =forge-visit-pullreq= to =forge-visit-topic= so that we may open closed pull requests from the magit status buffer.

#+begin_src emacs-lisp
  (use-package forge
    :disabled t
    :after magit
    :bind ((:map forge-pullreq-section-map
                 ([remap magit-visit-thing] . forge-visit-topic))))
#+end_src

Use this [[https://github.com/magit/magit/issues/460][tip]] to allow =magit= to manage dotfiles in a bare repository.

#+begin_src emacs-lisp
  (defcustom my-dotfiles-git-dir (expand-file-name "~/work/dotfiles.git")
    "Where the bare repository for dotfiles is located")

  (defun my-get-dotfile-dirs ()
    "Return a list of directories managed by dotfiles, or nil."
    (message "Calculating directories for dotfiles..")
    (let ((work-tree (expand-file-name "~/")))
      (if (file-directory-p my-dotfiles-git-dir)
          (let* ((git-dir (shell-command-to-string
                           (format "git --git-dir=%s --work-tree=%s ls-tree --full-tree --name-only -r HEAD"
                                   my-dotfiles-git-dir work-tree)))
                 (dotfile-dirs
                  (-map (apply-partially 'concat work-tree)
                        (-uniq (-keep #'file-name-directory (split-string git-dir))))))
            (message (format "... Found: %S" dotfile-dirs))
            dotfile-dirs)
        (progn
          (message (format "Not found: %s" my-dotfiles-git-dir))
          nil))))

  (defvar my-dotfile-dirs nil)

  (defun my-get-cached-dotfile-dirs ()
    "Return a cached list of directories managed by dotfiles."
    (unless my-dotfile-dirs
      (setq my-dotfile-dirs (my-get-dotfile-dirs)))
    my-dotfile-dirs)

  (defun my-magit-process-environment (env)
    "Detect and set git -bare repo ENV vars when in tracked dotfile directories."
    (let* ((default (file-name-as-directory (expand-file-name default-directory)))
           (work-tree (expand-file-name "~/"))
           (dotfile-dirs (my-get-cached-dotfile-dirs)))
      (push work-tree dotfile-dirs)
      (when (member default dotfile-dirs)
        (push (format "GIT_WORK_TREE=%s" work-tree) env)
        (push (format "GIT_DIR=%s" my-dotfiles-git-dir) env)))
    env)

  (advice-add 'magit-process-environment
              :filter-return #'my-magit-process-environment)
#+end_src

[[https://github.com/sshaw/git-link][git-link]] allows you to quickly create a URL pointing to a particular line in a forge repository.

#+begin_src emacs-lisp
  (use-package git-link
    :after magit)
#+end_src

[[https://github.com/dgutov/diff-hl][diff-hl]] highlights modified lines in the gutter.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :demand t
    :init
    ;; Stub to avoid error
    (defun smartrep-define-key (a b c)
      nil)
    :config
    (global-diff-hl-mode 1)
    :hook ((dired-mode . diff-hl-dired-mode)
           (magit-pre-refresh . diff-hl-magit-pre-refresh)
           (magit-post-refresh . diff-hl-magit-post-refresh)))
#+END_SRC

*** Links from regexp

Detect strings that look like Jira ticket identifiers and turn them into links.

#+begin_src emacs-lisp
  (defcustom my-jira-root "https://jira.atlassian.com"
    "Default link to your Jira root."
    :type 'string
    :group 'my-customs)

  (defcustom my-jira-pattern "\\(DEV\\|FOO\\)-[0-9]+"
    "Default pattern for detecting Jira tickets.
  For example, match strings like \"DEV-123\" or \"FOO-1\"."
    :type 'regexp
    :group 'my-customs)

  (use-package button-lock
    :config
    (defun my-toggle-jira-buttons ()
      (interactive)
      (if (bound-and-true-p button-lock-mode)
          (progn
            (message "Disabling button-lock-mode")
            (button-lock-clear-all-buttons)
            (button-lock-mode -1))
        (progn
          (message (format "Enabling button-lock-mode: %s [%s]" (buffer-name) major-mode))
          (button-lock-mode +1)
          (button-lock-set-button
           my-jira-pattern
           (lambda ()
             (interactive)
             (browse-url (concat my-jira-root
                                 "/browse/"
                                 (buffer-substring
                                  (previous-single-property-change (point) 'mouse-face)
                                  (next-single-property-change (point) 'mouse-face)))))
           :face (list 'org-link)
           :mouse-face 'custom-button-mouse
           :keyboard-binding "RET")
          ;; Magit tends to forget the `magit-visit-thing' keybindings
          (when (eq major-mode 'magit-status-mode)
            (define-key magit-status-mode-map (read-kbd-macro "RET") 'magit-show-commit))
          (when (eq major-mode 'magit-log-mode)
            (define-key magit-log-mode-map (read-kbd-macro "RET") 'magit-show-commit))
          ;; Make sure the new link style is applied
          (run-at-time "0.1 sec" nil #'font-lock-update))))
    :hook ((magit-revision-mode) . my-toggle-jira-buttons))
#+end_src

*** Confluence

The =confluence-reader= package is not yet in MELPA, so download it from =sourcehut=.

Customize =confluence-host= to match the desired target host (e.g. "mycompany.atlassian.net").

#+begin_src emacs-lisp
  (use-package confluence-reader
    :ensure (:host sourcehut :repo "sebasmonia/confluence-reader.el")
    :commands (confluence-search confluence-page-by-id confluence-page-from-url)
    :config
    ;; Show search window in the bottom
    (add-to-list
     'display-buffer-alist
     '("\\*Confluence search\\*" display-buffer-in-direction
       (direction . bottom)
       (window . root)
       (window-height . 0.3))))
#+end_src

** Programming
*** References
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src emacs-lisp
  (use-package xref
    :ensure nil
    :after general
    :general
    ("M-." 'xref-find-references)
    ("<C-.>" 'xref-find-definitions)
    ("<C-return>" 'xref-find-definitions)
    :custom
    (xref-prompt-for-identifier nil))
#+end_src

As an alternative to =LSP=, =ctags= can be used to statically analyze source code and keep track of e.g. function definitions by creating a =TAGS= file. Here we use [[https://ctags.io/][Universal Ctags]] as the indexer and [[https://github.com/redguardtoo/counsel-etags][counsel-etags]] as the frontend.

The location of the "project root" for indexing can be set by creating a =.dir-locals.el= file where e.g.

#+begin_src elisp :tangle no
  ((nil . ((counsel-etags-project-root . "/Users/lassemaatta/personal/some-project/resources/private"))))
#+end_src

=counsel-etags-update-tags-force= can be used to refresh the =TAGS= manually.

#+begin_src emacs-lisp
  (use-package counsel-etags
    :after xref
    :demand t
    :custom
    (counsel-etags-ctags-program "uctags")
    (counsel-etags-update-interval 60))
#+end_src

*** Nested editing
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src emacs-lisp
  (use-package separedit
    :custom
    (separedit-preserve-string-indentation t))
#+end_src

*** Error checking (=flycheck= or =flymake=)
:PROPERTIES:
:VISIBILITY: folded
:END:

As =eglot= is built-in into =emacs=, it only supports the also built-in =flymake=.

#+begin_src emacs-lisp
  (use-package flymake
    :if my-use-eglot
    :ensure nil
    :after (eglot general)
    :general
    (my-leader-def
      :keymaps 'flymake-mode-map
      "en" '(flymake-goto-next-error :which-key "Goto next")
      "el" '(flymake-show-buffer-diagnostics :which-key "List errors")))
#+end_src

However, we can use =flycheck-eglot= to bridge =flymake= diagnostics from =eglot= to =flycheck=.

#+begin_src emacs-lisp
  (use-package flycheck-eglot
    :if my-use-eglot
    :after (flycheck eglot)
    :config
    (global-flycheck-eglot-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package flycheck
    :general
    (my-leader-def
      :keymaps 'flycheck-mode-map
      "en" '(flycheck-next-error :which-key "Goto next")
      "ep" '(flycheck-previous-error :which-key "Goto previous")
      "el" '(flycheck-list-errors :which-key "List errors"))
    :hook ((prog-mode . flycheck-mode))
    :custom
    (flycheck-display-errors-delay 1.0)
    (flycheck-check-syntax-automatically '(save idle-change idle-buffer-switch new-line mode-enabled))
    :config
    (setq flycheck-error-list-format `[("File" 10)
                                       ("Line" 5 flycheck-error-list-entry-< :right-align t)
                                       ("Col" 4 nil :right-align t)
                                       ("Level" 8 flycheck-error-list-entry-level-<)
                                       ("ID" 16 t)
                                       (,(flycheck-error-list-make-last-column "Message" 'Checker) 0 t)])
    (define-key flycheck-mode-map flycheck-keymap-prefix nil)
    ;; Fine tune error list location
    (add-to-list 'display-buffer-alist
                 `(,(rx bos "*Flycheck errors*" eos)
                   (display-buffer-reuse-window
                    display-buffer-in-side-window)
                   (side            . bottom)
                   (reusable-frames . visible)
                   (window-height   . 6)))
    ;; Open (and close) the error list automatically
    (defun my-close-error-list ()
      "Closes the flycheck error list"
      (-when-let* ((error-window (get-buffer-window flycheck-error-list-buffer)))
        (delete-window error-window)))
    (defun my-window-change-fn (window)
      "After the buffer changes, close the error window if it's empty"
      (when (not flycheck-current-errors)
        (my-close-error-list)))
    (add-hook 'flycheck-after-syntax-check-hook
              (lambda  ()
                (add-to-list 'window-buffer-change-functions #'my-window-change-fn)
                (if flycheck-current-errors
                    (flycheck-list-errors)
                  (my-close-error-list)))))
#+end_src

Use [[https://github.com/flycheck/flycheck-pos-tip][flycheck-pos-tip]] so that errors on point show up in a tooltip instead of echo area. Otherwise the error will hide the function signature.

#+begin_src emacs-lisp
  (use-package flycheck-pos-tip
    :after (flycheck)
    :init
    (flycheck-pos-tip-mode))
#+end_src

[[https://github.com/minad/consult-flycheck][consult-flycheck]] provides a nice `consult-flycheck` command for navigating =flycheck= errors.

#+begin_src emacs-lisp
  (use-package consult-flycheck
    :after (consult flycheck)
    :bind (("C-d" . consult-flycheck)))
#+end_src

Use =hl-todo= to highlight any =TODO= comments in code.

#+begin_src emacs-lisp
  (use-package hl-todo
    :hook (((prog-mode
             org-mode) . hl-todo-mode))
    :custom
    (hl-todo-keyword-faces '(("TODO" . (face-attribute 'modus-themes-fg-red-intense :foreground))
                             ("FIXME" . "#FF0000"))))
#+end_src

*** Completion (=corfu=)
:PROPERTIES:
:VISIBILITY: folded
:END:

Regardless of completion provider, always try to complete =<tab>=.

#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src

Use [[https://github.com/minad/corfu][corfu]] for completion at point functionality, similar to =company=.

While completing, use =SPC= to add a separator, which does not abort the completion but instead allows you to add more search words.

When looking at completion candidates with =corfu=, we can use =corfu-popupinfo= to show a documentation popup with docstrings et al.

#+begin_src emacs-lisp
  (use-package corfu
    :demand t
    :config
    (global-corfu-mode)
    (corfu-popupinfo-mode)
    (corfu-history-mode -1)
    (add-to-list 'savehist-additional-variables 'corfu-history)
    :bind ((:map corfu-map
                 ("SPC" . corfu-insert-separator)
                 ("TAB" . corfu-next)
                 ([tab] . corfu-next)
                 ("S-TAB" . corfu-previous)
                 ([backtab] . corfu-previous)))
    :custom
    (corfu-auto nil)
    (corfu-preselect 'prompt)
    (corfu-popupinfo-delay '(0.5 . 1.0))
    (corfu-cycle t)
    (corfu-on-exact-match nil)
    (corfu-quit-no-match t)
    (corfu-preview-current nil)
    (corfu-min-width 70)
    (corfu-count 20))
#+end_src

Add icons to completion menu with =kind-icon=.

#+begin_src emacs-lisp
  (use-package kind-icon
    :demand t
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default)
    (kind-icon-default-style '(:padding 0 :stroke 0 :margin 0 :radius 0 :height 0.8 :scale 1.0))
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

#+begin_src emacs-lisp
  (use-package corfu-candidate-overlay
    :after corfu
    :disabled t
    :config
    (corfu-candidate-overlay-mode +1))
#+end_src

*** Snippets (=yasnippet=)
:PROPERTIES:
:VISIBILITY: folded
:END:

[[https://github.com/joaotavora/yasnippet][yasnippet]] provides snippet functionality. Disable the whole keymap, so that it doesn't clobber up the =C-c= keymap.

Also, move =yas-expand= from =<tab>= to =C-S-<tab>= so that it doesn't accidentally activate.

#+begin_src emacs-lisp
  (use-package yasnippet
    :hook (((clojure-mode java-mode) . yas-minor-mode))
    :bind (:map yas-minor-mode-map
                ("<tab>" . nil)
                ("TAB" . nil)
                ("C-S-<iso-lefttab>" . yas-expand))
    :config
    (define-key yas-minor-mode-map (kbd "C-c &") nil))
#+end_src

Load some =clojure= specific snippets.

#+begin_src emacs-lisp
  (use-package clojure-snippets
    :after (yasnippet clojure-mode)
    :config
    (yas-reload-all))
#+end_src

[[https://github.com/mohkale/consult-yasnippet][consult-yasnippet]] provides a nice list with previews when choosing a snippet.

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :after (yasnippet org)
    :bind  (("C-ö" . consult-yasnippet)))
#+end_src

*** Language Server Protocol
:PROPERTIES:
:VISIBILITY: folded
:END:

We use either =lsp-mode= or =eglot=, depending on =my-use-eglot=.

See the [[https://github.com/minad/corfu/wiki#advanced-example-configuration-with-orderless][Corfu wiki]] on how =corfu= and =orderless= completion can be configured for =lsp-mode= or =eglot=.

**** Eglot
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src emacs-lisp
  (use-package eglot
    :if my-use-eglot
    :ensure nil
    :after (general cape)
    :general
    (my-leader-def
      :keymaps 'eglot-mode-map
      "ld" '(eldoc-box-help-at-point :which-key "Glance docs")
      "la" '(eglot-code-actions :which-key "Code actions")
      "lr" '(eglot-rename :which-key "Rename symbol")
      "lR" '(eglot-shutdown :which-key "Restart LSP"))
    :hook
    ((clojure-mode
      clojurescript-mode
      clojurec-mode
      js-ts-mode
      typescript-ts-mode) . eglot-ensure)
    (eglot-managed-mode . my-eglot-loaded)
    :custom
    (eglot-connect-timeout 300)
    (eglot-sync-connect 1)
    (eglot-autoshutdown t)
    (eglot-extend-to-xref t)
    (eglot-confirm-server-initiated-edits nil)
    (eglot-send-changes-idle-time 1.0)
    :config
    (add-to-list 'completion-category-overrides '((eglot (styles orderless))
                                                  (eglot-capf (styles orderless))))
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
    (fset 'my-eglot-completion-at-point (cape-capf-super
                                         #'eglot-completion-at-point
                                         #'cape-file))
    ;; Don't log every event for better performance
    (fset #'jsonrpc--log-event #'ignore)
    ;; Don't show hover documentation in echo area
    (defalias 'my-display-in-echo-area (my-remove-by-source 'eldoc-display-in-echo-area
                                                            'eglot-hover-eldoc-function))
    ;; Only show hover documentation in doc buffer
    (defalias 'my-display-in-buffer (my-filter-by-source 'eldoc-display-in-buffer
                                                         'eglot-hover-eldoc-function))
    (defun my-eglot-loaded ()
      (remove-hook 'completion-at-point-functions #'eglot-completion-at-point t)
      (add-hook 'completion-at-point-functions #'my-eglot-completion-at-point nil t)
      (setq eldoc-display-functions (list 'my-display-in-echo-area
                                          'my-display-in-buffer))))
#+end_src

=lsp-mode= has it's own mechanism for traversing into =.jar= files etc, but for =eglot= we need to use =jarchive=.

#+begin_src emacs-lisp
  (use-package jarchive
    :after eglot
    :demand t
    ;; Temporarily fetch latest from git due to bug(s).
    :ensure (:host sourcehut :repo "dannyfreeman/jarchive/")
    :config
    (jarchive-setup))
#+end_src

**** lsp-mode
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :if (not my-use-eglot)
    :general
    (my-leader-def
      :keymaps 'lsp-mode-map
      "lR" '(lsp-workspace-restart :which-key "Restart workspace"))
    :custom
    (lsp-completion-provider :none)
    (lsp-completion-sort-initial-results nil)
    ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
    (lsp-keymap-prefix "C-f l")
    (lsp-idle-delay 0.5)
    (lsp-eldoc-enable-hover t)
    (lsp-lens-enable t)
    (lsp-headerline-breadcrumb-enable nil)
    ;; Close LSP server when last buffer closed
    (lsp-keep-workspace-alive nil)
    ;; Don't include the var/function declaration itself when listing references to a var/function
    (lsp-references-exclude-definition t)
    ;; We use yasnippet, but not through LSP
    (lsp-enable-snippet nil)
    ;; Prefer clojure-mode indentation
    (lsp-enable-indentation nil)
    (lsp-modeline-code-actions-enable nil)
    (lsp-imenu-index-function #'lsp-imenu-create-categorized-index)
    ;; For logging IO between client and server
    (lsp-log-io nil)
    ;(lsp-clojure-custom-server-command '("bash" "-c" "/home/lassemaatta/Lataukset/clojure-lsp"))
    :init
    (defun my/lsp-mode-setup-completion ()
      ;; Make sure LSP completion comes last and thus doesn't consume all completions
      (delete #'lsp-completion-at-point completion-at-point-functions)
      (add-to-list 'completion-at-point-functions #'lsp-completion-at-point t)
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless)))
    :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
           (clojure-mode . lsp)
           (clojurescript-mode . lsp)
           (clojurec-mode . lsp)
           (js-ts-mode . lsp)
           (typescript-ts-mode . lsp)
           ;; if you want which-key integration
           (lsp-mode . lsp-enable-which-key-integration)
           (lsp-completion-mode . my/lsp-mode-setup-completion)
           (lsp-after-apply-edits . (lambda (op)
                                      (save-some-buffers t))))
    :bind (("<C-M-return>" . lsp-describe-thing-at-point))
    :commands (lsp lsp-deferred))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :after (lsp-mode)
    :general
    (my-leader-def
      :keymaps 'lsp-mode-map
      "ld" '(lsp-ui-doc-glance :which-key "Glance docs"))
    :custom
    (lsp-ui-sideline-show-code-actions nil)
    (lsp-ui-sideline-enable nil)
    (lsp-ui-doc-show-with-cursor nil)
    (lsp-ui-doc-show-with-mouse nil)
    (lsp-ui-peek-list-width 75) ; Default is 50
    (lsp-ui-peek-peek-height 40)) ; Default is 20 rows
#+END_SRC

Shortcut for =imenu=, using either =lsp-ui-imenu= or =consult-imenu=
depending on whether the current buffer is using =LSP=.

#+BEGIN_SRC emacs-lisp
  (defun show-or-hide-imenu ()
    (interactive)
    (cond
     ((derived-mode-p 'lsp-ui-imenu-mode) (lsp-ui-imenu--kill))
     ((bound-and-true-p lsp-mode) (lsp-ui-imenu))
     ((active-minibuffer-window) (exit-minibuffer))
     (t (consult-imenu))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package lsp-treemacs
    :after (lsp-mode)
    :bind (("<f2>" . lsp-treemacs-symbols)
           ("<f3>" . lsp-treemacs-call-hierarchy))
    :custom
    (lsp-treemacs-error-list-severity 1)
    (lsp-treemacs-symbols-sort-functions '(lsp-treemacs-sort-by-name))
    (lsp-treemacs-errors-position-params '((side . right))))
#+END_SRC

=consult-lsp= provides nice utility functions such as =consult-lsp-diagnostics= or =consult-lsp-symbols=.

#+BEGIN_SRC emacs-lisp
  (use-package consult-lsp
    :after (flycheck lsp-mode org)
    :general
    (my-leader-def
      :keymaps 'flycheck-mode-map
      "ed" '(consult-lsp-diagnostics :which-key "LSP diagnostics")))
#+END_SRC

**** Java
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
  (use-package lsp-java
    :after (lsp-mode)
    :hook ((java-mode . lsp)
           (java-ts-mode . lsp))
    :bind (:map java-mode-map
              ("<tab>" . indent-for-tab-command))
    :custom
    (lsp-enable-snippets t)
    (lsp-java-maven-download-sources t)
    (lsp-java-java-path "/usr/lib/jvm/default-runtime/bin/java")
    (lsp-java-jdt-download-url "https://www.eclipse.org/downloads/download.php?file=/jdtls/milestones/1.36.0/jdt-language-server-1.36.0-202405301306.tar.gz")
    :config
    (defun my-format-on-save ()
      (message "format on save")
      (when (eq major-mode 'java-mode)
        (lsp-format-buffer)))
    (add-hook 'before-save-hook 'my-format-on-save))
#+END_SRC

#+begin_src emacs-lisp
  (use-package java-snippets
    :after (yasnippet lsp-java)
    :demand t)
#+end_src

*** Language Modes
:PROPERTIES:
:VISIBILITY: children
:END:
**** Web mode

#+begin_src emacs-lisp
  (use-package web-mode
    :after smartparens
    :init
    (defun my-web-mode-hook ()
      (setq web-mode-enable-auto-pairing nil))
    (defun sp-web-mode-is-code-context (id action context)
      (and (eq action 'insert)
           (not (or (get-text-property (point) 'part-side)
                    (get-text-property (point) 'block-side)))))
    :mode ("\\.html\\'" . web-mode)
    :hook (web-mode . my-web-mode-hook)
    :custom
    (web-mode-markup-indent-offset 2)
    :config
    (sp-local-pair 'web-mode "<" nil :when '(sp-web-mode-is-code-context)))
#+end_src

**** HTML
Set =.html= indentation from 2 to 4.

#+BEGIN_SRC emacs-lisp
  (add-hook 'html-mode-hook
            (lambda ()
              (set (make-local-variable 'sgml-basic-offset) 4)))
#+END_SRC

**** Log files

#+begin_src emacs-lisp
  (use-package logview
    :bind (:map logview-mode-map
                ("?" . major-mode-hydra))
    :config
    (major-mode-hydra-define logview-mode nil
      ("Filter level"
       (("l 1" logview-show-only-errors "Errors" :exit nil)
        ("l 2" logview-show-errors-and-warnings "+ Warnings" :exit nil))
       "Other"
       (("q" bury-buffer "Quit")))))
#+end_src

**** Docker and =docker-compose=

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package docker-compose-mode)
#+END_SRC

**** Jenkins

Open anything starting with =Jenkinsfile= in =jenkinsfile-mode=.

#+begin_src emacs-lisp
  (use-package jenkinsfile-mode
    :mode ("/Jenkinsfile.*" . jenkinsfile-mode))
#+end_src

**** Graphviz and =dot=

#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode
    :hook ((dot . graphviz-dot-mode))
    :custom
    (graphviz-dot-indent-width 2))
#+END_SRC

**** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode)
#+END_SRC

**** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode)
#+END_SRC

[[https://github.com/DamienCassou/json-navigator][json-navigator]] provides a nice tree view of large =JSON= structures.

#+BEGIN_SRC emacs-lisp
  (use-package json-navigator
    :defer t)
#+END_SRC

#+begin_src emacs-lisp
  (use-package json-par
    :hook ((json-mode . json-par-mode))
    :config
    (defhydra hydra-json-par (:hint nil)
      "
  ^Move^
  ^^^^^^^^-----------------------------------------------------------------
  _j_: forward-member   _h_: up + backward
  _k_: backward-member  _l_: up + forward
  _a_: line-start       _I_: insert \"\":\"\"
  _e_: line-end
  _A_: list-start
  _E_: list-end
  "
      ("j" #'json-par-forward-member)
      ("k" #'json-par-backward-member)
      ("J" #'json-par-forward-record)
      ("K" #'json-par-backward-record)
      ("a" #'json-par-beginning-of-member)
      ("e" #'json-par-end-of-member)
      ("A" #'json-par-beginning-of-list)
      ("E" #'json-par-end-of-list)
      ("h" #'json-par-up-backward)
      ("l" #'json-par-up-forward)
      ("I" (lambda ()
             (interactive)
             (json-par-end-of-member)
             (json-par-insert-comma)
             (json-par-insert-double-quotes)
             (save-excursion
               (forward-char)
               (json-par-insert-colon)
               (forward-char)
               (json-par-insert-double-quotes)))))
    (define-key json-mode-map "\C-fj" 'hydra-json-par/body)
    (eval-after-load 'which-key
      (which-key-add-key-based-replacements "C-f j" "JSON")))
#+end_src

**** Javascript

#+begin_src emacs-lisp
  (defun my-update-symref ()
    (require 'semantic/symref/grep)
    (add-to-list #'semantic-symref-filepattern-alist
                 '(js-ts-mode "*.js")))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package js
    :ensure nil
    :mode ("\\.js\\'" . js-ts-mode)
    :hook (js-ts-mode . my-update-symref)
    :custom
    (js-indent-level 2))
#+END_SRC

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :mode ("\\.ts\\'" . typescript-ts-mode))
#+end_src

**** SSH config files

#+BEGIN_SRC emacs-lisp
  (use-package ssh-config-mode)
#+END_SRC

**** Ansible Vault

#+begin_src emacs-lisp
  (use-package ansible-vault)
#+end_src

**** Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode
    :init
    ;; Fix for https://github.com/jrblevin/markdown-mode/issues/578
    (setq native-comp-jit-compilation-deny-list '("markdown-mode\\.el$")))
#+end_src

*** Lisp
:PROPERTIES:
:VISIBILITY: children
:END:
**** =smartparens=
Note that the =*scratch*= buffer uses =emacs-lisp-mode=, therefore =smartparens= loads on startup.

#+begin_src emacs-lisp
  (use-package smartparens
    :hook ((emacs-lisp-mode
            clojure-mode
            cider-repl-mode
            lisp-mode
            sly-mrepl-mode
            java-mode) . turn-on-smartparens-strict-mode)
    :bind (("C-<left>" . sp-backward-symbol)
           ("C-<right>" . sp-forward-symbol)
           ("M-C-<left>" . sp-backward-sexp)
           ("M-C-<right>" . sp-forward-sexp)
           ("M-7" . sp-backward-slurp-sexp)
           ("M-8" . sp-backward-barf-sexp)
           ("M-9" . sp-forward-barf-sexp)
           ("M-0" . sp-forward-slurp-sexp))
    :config
    (require 'smartparens-config)
    (show-smartparens-global-mode -1))
#+end_src

#+begin_src elisp
  (use-package evil-cleverparens
    :if use-evil
    :hook ((emacs-lisp-mode
            clojure-mode
            cider-repl-mode) . evil-cleverparens-mode))
#+end_src

Somewhat related, =expand-region= provides two nice tools to either expand or contract the selected region semantically (ie. it understands S-expressions, strings, ..).

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-S-<up>" . er/expand-region)
           ("C-S-<down>" . er/contract-region)))
#+end_src

**** =highlight-parentheses=

Let's use =highlight-parentheses= to always highlight the nearest parentheses. This makes it easier to see where =barf= and =slurp= will apply.

Note that this only highlights =()[]{}= pairs, but not =""''= etc.

#+begin_src emacs-lisp
  ;; Register a custom post-handler so that the highlighted parentheses are updated
  (defun refresh-highlight (id action context)
    (when (member action '(barf-forward
                           barf-backward
                           slurp-forward
                           slurp-backward))
      ;; clear the last point location so that highlight-parentheses will
      ;; re-run the highlight analysis even when the point doesn't move
      (setq highlight-parentheses--last-point 0)))

  (use-package highlight-parentheses
    :after smartparens
    :custom
    (highlight-parentheses-colors '("spring green"))
    :hook
    ((emacs-lisp-mode
      clojure-mode
      lisp-mode
      sly-mrepl-mode) . highlight-parentheses-mode)
    :config
    (sp-local-pair 'lisp-mode "(" nil :post-handlers '(:add refresh-highlight))
    (sp-local-pair 'emacs-lisp-mode "(" nil :post-handlers '(:add refresh-highlight))
    (sp-local-pair 'clojure-mode "(" nil :post-handlers '(:add refresh-highlight))
    (sp-local-pair 'clojure-mode "[" nil :post-handlers '(:add refresh-highlight)))
#+end_src

*** Clojure
:PROPERTIES:
:VISIBILITY: children
:END:
**** =clojure-mode=

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :init
    (defun my-lein-deps ()
      (interactive)
      (my-run-shell-cmd "lein deps :tree" "*lein-deps*" "*lein-deps-err*"))
    (defun my-lein-outdated ()
      (interactive)
      (my-run-shell-cmd "lein outdated" "*lein-outdated*" "*lein-outdated-err*"))
    :general
    (my-leader-def
      :keymaps 'clojure-mode-map
      :major-modes t
      "m"  '(:ignore t :which-key "Clojure")
      "md" '(my-lein-deps :which-key "lein dependencies")
      "mo" '(my-lein-outdated :which-key "lein outdated"))
    :custom
    (clojure-indent-style 'align-arguments)
    (clojure-align-forms-automatically t)
    (clojure-align-separator 'entire))
#+END_SRC

**** =cider=

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :general
    ("C-." 'cider-find-dwim)
    (my-leader-def
      :keymaps 'clojure-mode-map
      :major-modes t
      "m"  '(:ignore t :which-key "Clojure")
      "mc" '(cider-connect :which-key "Cider connect")
      "ml" '(cider-log-show :which-key "Cider logging"))
    (my-leader-def
      :predicate '(cider-connected-p)
      :keymaps 'clojure-mode-map
      :major-modes t
      "hc" '(cider-clojuredocs :which-key "Clojuredocs")
      "hC" '(cider-clojuredocs-web :which-key "Clojuredocs (browse)")
      "mn" '(cider-browse-ns :which-key "Browse namespaces")
      "mr" '(cider-switch-to-repl-buffer :which-key "Switch to REPL")
      "mR" '(my-cider-user-reset :which-key "Reset (system)")
      "ml" '(my-cider-reveal-clear :which-key "Clear reveal window")
      "tt" '(cider-test-run-test :which-key "Run test")
      "tn" '(cider-test-run-ns-tests :which-key "Run namespace tests")
      "tp" '(cider-test-run-project-tests :which-key "Run project tests")
      "tr" '(cider-test-rerun-test :which-key "Rerun last test"))
    (my-leader-def
      :predicate '(cider-connected-p)
      :keymaps 'cider-repl-mode-map
      :major-modes t
      "m"  '(:ignore t :which-key "Clojure (REPl)")
      "mr" '(cider-switch-to-last-clojure-buffer :which-key "Switch back")
      "ml" '(cider-log-show :which-key "Cider logging"))
    (my-leader-def
      :predicate '(cider-connected-p)
      :keymaps 'clojure-mode-map
      "xl" '(cider-eval-last-sexp :which-key "Eval last")
      "xe" '(cider-eval-defun-at-point :which-key "Eval defun"))
    :init
    (defun my-cider-eval (cmd)
      (cider-interactive-eval cmd nil nil (cider--nrepl-pr-request-map)))
    (defun my-cider-user-reset ()
      (interactive)
      (my-cider-eval "(ns user) (user/reset)"))
    (defun my-cider-reveal-clear ()
      (interactive)
      (my-cider-eval "(tap> {:vlaaad.reveal/command '(clear-output)})"))
    (defun my-cider-test-infer-test-ns (ns)
      "Given a namespace NS, find the corresponding test namespace (which may be NS itself)."
      (when ns
        ;; Check if we're currently in a test namespace?
        (if (or (string-suffix-p "-test" ns)
                (string-suffix-p "-itest" ns))
            ns
          ;; We're not -> check if Cider knows a matching -test or -itest namespace
          (let ((namespaces (cider-sync-request:ns-list))
                (unit-test-ns (concat ns "-test"))
                (integration-test-ns (concat ns "-itest"))
                (i-ntegration-test-ns (concat ns "-i-test")))
            (cond
             ;; Cider can't match multiple so prefer the unit-test namespace
             ((member unit-test-ns namespaces) unit-test-ns)
             ((member integration-test-ns namespaces) integration-test-ns)
             ((member i-ntegration-test-ns namespaces) i-ntegration-test-ns)
             (t unit-test-ns))))))
    :custom
    (nrepl-log-messages t)
    (cider-repl-buffer-size-limit 10000)
    (cider-print-quota 512)
    (cider-repl-pop-to-buffer-on-connect nil)
    (cider-repl-use-clojure-font-lock t)
    (cider-reuse-dead-repls 'auto)
    (cider-save-file-on-load t)
    (cider-font-lock-dynamically '(macro core function var))
    (cider-eldoc-display-for-symbol-at-point nil)
    (cider-offer-to-open-cljs-app-in-browser nil)
    (nrepl-hide-special-buffers t)
    (cider-overlays-use-font-lock t)
    (cider-default-cljs-repl 'shadow)
    (cider-enrich-classpath nil)
    (cider-repl-history-file (concat user-emacs-directory "/cider-history"))
    (cider-repl-display-in-current-window t)
    (cider-test-infer-test-ns #'my-cider-test-infer-test-ns)
    (cider-dynamic-indentation nil)
    ;; Give lower priority to cider xref backend over LSP
    (cider-xref-fn-depth 0)
    (cider-use-xref t)
    (cider-use-tooltips nil)
    :hook
    ((cider-mode . my-cider-refresh))
    :config
    (defun my-cider-loaded ()
      (message "Cider loaded: post actions")
      ;; Choose which completion-at-point provider we use
      (if my-prefer-lsp-completion-at-point
          (remove-hook 'completion-at-point-functions #'cider-complete-at-point t)
        (if my-use-eglot
            (remove-hook 'completion-at-point-functions #'my-eglot-completion-at-point t)
          (remove-hook 'completion-at-point-functions #'lsp-completion-at-point t)))
      ;; Prefer LSP xref backend
      (setq xref-backend-functions (delete 'cider--xref-backend xref-backend-functions))
      ;; Prefer cider signature documentation over LSP
      (if my-use-eglot
        (remove-hook 'eldoc-documentation-functions #'eglot-signature-eldoc-function t)
       (remove-hook 'eldoc-documentation-functions #'lsp-eldoc-function t)))
    (defun my-cider-unloaded ()
      (message "Cider unloaded: post actions")
      (if my-use-eglot
          (add-hook 'completion-at-point-functions #'my-eglot-completion-at-point nil t)
        (add-hook 'completion-at-point-functions #'lsp-completion-at-point nil t))
      (if my-use-eglot
          (add-hook 'eldoc-documentation-functions #'eglot-signature-eldoc-function nil t)
        (add-hook 'eldoc-documentation-functions #'lsp-eldoc-function nil t)))
    (defun my-cider-refresh ()
      (interactive)
      (if (bound-and-true-p cider-mode)
          (my-cider-loaded)
        (my-cider-unloaded)))
    (cider-repl-toggle-pretty-printing)

    (put-clojure-indent 'testit/fact 1)
    (put-clojure-indent 'testit.core/fact 1)
    (put-clojure-indent 'page/html5 1)
    (put-clojure-indent 'facts 1)
    (put-clojure-indent 'facts* 1)
    (put-clojure-indent 'fact 1)
    (put-clojure-indent 'rf/reg-event-fx 1)
    (put-clojure-indent 'chain/reg-chain 1)
    (put-clojure-indent 'rf/reg-sub 1)
    (put-clojure-indent 'rf/reg-event-db 1)
    (put-clojure-indent 'rf/reg-fx 1)
    (put-clojure-indent 'futil/for-all 1)
    (put-clojure-indent 'futil/for-frag 1)
    (put-clojure-indent 'for-frag 1)
    (put-clojure-indent 'for-all 1)
    (put-clojure-indent 'u/for-all 1)
    (put-clojure-indent 'or-join 1)
    (put-clojure-indent 'not-join 1)
    (put-clojure-indent 'r/with-let 1)
    (put-clojure-indent 'p/if-all-let 1)
    (put-clojure-indent 'test-seq/seq-tx 1)
    (put-clojure-indent 'cc/button 1)
    (put-clojure-indent 'cc/modal-body 1)
    (put-clojure-indent 'cc/modal-footer 1)
    (put-clojure-indent 'cc/composed-modal 1)
    (put-clojure-indent 'against-background 1)
    (put-clojure-indent 'GET 2)
    (put-clojure-indent 'POST 2)
    (put-clojure-indent 'PUT 2)
    (put-clojure-indent 'context 2)
    (put-clojure-indent 'util/pcond-> 1)
    (put-clojure-indent 'util/pcond->> 1)
    (put-clojure-indent 'mongocheck 1))
#+END_SRC

**** Utilities

#+BEGIN_SRC emacs-lisp
  (defun jet-transit-to-edn ()
    "Run transit->edn conversion on the active buffer."
    (interactive)
    (shell-command-on-region
     (region-beginning)
     (region-end)
     "jet --pretty --from transit --edn-reader-opts '{:default tagged-literal}'"
     (current-buffer)
     t
     "*jet error buffer*"
     t))

  (defun jet-edn-to-edn ()
    "Format EDN in the active buffer region."
    (interactive)
    (shell-command-on-region
     (region-beginning)
     (region-end)
     "jet --pretty --from edn --edn-reader-opts '{:default tagged-literal}'"
     (current-buffer)
     t
     "*jet error buffer*"
     t))

  (defun my-xml-pretty-format ()
    (interactive)
    (save-excursion
      (shell-command-on-region (point-min) (point-max) "xmllint --format -" (buffer-name) t)
      (nxml-mode)
      (indent-region begin end)))
#+END_SRC

*** Common Lisp
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src emacs-lisp
  (use-package sly
    :custom
    (inferior-lisp-program "sbcl"))
#+end_src

** Terminal
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src emacs-lisp
  (use-package vterm
    :ensure (vterm :post-build
                   (progn
                     (setq vterm-always-compile-module t)
                     (require 'vterm)
                     ;;print compilation info for elpaca
                     (with-current-buffer (get-buffer-create vterm-install-buffer-name)
                       (goto-char (point-min))
                       (while (not (eobp))
                         (message "%S"
                                  (buffer-substring (line-beginning-position)
                                                    (line-end-position)))
                         (forward-line)))
                     (when-let ((so (expand-file-name "./vterm-module.so"))
                                ((file-exists-p so)))
                       (make-symbolic-link
                        so (expand-file-name (file-name-nondirectory so)
                                             "../../builds/vterm")
                        'ok-if-already-exists))))
    :commands (vterm)
    :hook (vterm-mode . my-on-vterm)
    :config
    (defun my-on-vterm ()
      (setq-local global-hl-line-mode nil)))
#+end_src

** Recreational
:PROPERTIES:
:VISIBILITY: folded
:END:

*** Feeds

[[https://github.com/skeeto/elfeed][elfeed]] is a web feed reader for =emacs=. This [[https://karthinks.com/software/lazy-elfeed/][article]] contains a couple of tips for =elfeed=, adapted below.

#+begin_src emacs-lisp
  (use-package elfeed
    :commands (elfeed)
    :bind (:map elfeed-show-mode-map
                ("B" . my-elfeed-show-eww-open)
                ("?" . major-mode-hydra)
                :map elfeed-search-mode-map
                ("B" . my-elfeed-search-eww-open)
                ("?" . major-mode-hydra))
    :custom
    (elfeed-search-filter "@4-week-ago ")
    (elfeed-search-title-max-width 300)
    (elfeed-search-trailing-width 50)
    (elfeed-feeds
     '(("https://planet.emacslife.com/atom.xml" emacs)
       ("https://planet.clojure.in/atom.xml" clojure)
       ("http://reddit.com/r/emacs/.rss" emacs reddit)
       ("http://reddit.com/r/clojure/.rss" clojure reddit)
       ("http://reddit.com/r/clojurescript/.rss" clojure reddit)
       ("https://clojure.org/feed.xml" clojure)
       ("https://hnrss.org/frontpage" news)
       ("https://feeds.yle.fi/uutiset/v1/majorHeadlines/YLE_UUTISET.rss" news)
       ("https://www.hs.fi/rss/teasers/etusivu.xml" news)))
    :config
    (setq my-elfeed-tags '())
    (defun my-elfeed-toggle-tag (tag)
      "Add or remove TAG from my-elfeed-tags. Returns true if added."
      (setq my-elfeed-tags
            (if (-contains? my-elfeed-tags tag)
                (-remove-item tag my-elfeed-tags)
              (cons tag my-elfeed-tags)))
      (setq elfeed-search-filter
            (-reduce-from (lambda (acc tag) (concat acc "+" tag " ")) "@4-week-ago " my-elfeed-tags))
      (elfeed-search-update :force)
      (-contains? my-elfeed-tags tag))
    (defmacro my-def-elfeed-tag-toggle (tag)
      "Registers a variable and command for my-elfeed-tag-TAG."
      (let ((var-name (intern (concat "my-elfeed-tag-" tag))))
        `(defun ,var-name ()
           (interactive)
           (setq ,var-name (my-elfeed-toggle-tag ,tag)))))
    (my-def-elfeed-tag-toggle "emacs")
    (my-def-elfeed-tag-toggle "clojure")
    (my-def-elfeed-tag-toggle "news")
    (my-def-elfeed-tag-toggle "reddit")
    (defun my-elfeed-show-eww-open (&optional use-generic-p)
      (interactive "P")
      (let ((browse-url-browser-function #'eww-browse-url))
        (elfeed-show-visit use-generic-p)))
    (defun my-elfeed-search-eww-open (&optional use-generic-p)
      (interactive "P")
      (let ((browse-url-browser-function #'eww-browse-url))
        (elfeed-search-browse-url use-generic-p)))
    (major-mode-hydra-define elfeed-search-mode
      (:color pink)
      ("Feeds"
       (("s" elfeed-search-live-filter "Search filter")
        ("c" elfeed-search-clear-filter "Clear filter")
        ("G" elfeed-search-fetch "Update feeds"))
       "Tags"
       (("te" my-elfeed-tag-emacs "Emacs" :toggle t :color red)
        ("tc" my-elfeed-tag-clojure "Clojure" :toggle t :color red)
        ("tn" my-elfeed-tag-news "News" :toggle t :color red)
        ("tr" my-elfeed-tag-reddit "Reddit" :toggle t :color red))
       "Mark"
       (("r" elfeed-search-untag-all-unread "as read")
        ("u" elfeed-search-tag-all-unread "as unread"))
       "Open"
       (("B" my-elfeed-search-eww-open "Open in EWW"))))
    (major-mode-hydra-define elfeed-show-mode nil
      ("Open"
       (("B" my-elfeed-show-eww-open "Open in EWW"))
       "Links"
       (("C-i" shr-next-link "Next link" :color red)
        ("C-M-i" shr-previous-link "Previous link" :color red)))))
#+end_src

**** Hacker news

#+begin_src emacs-lisp
  (use-package hnreader
    :disabled)
#+end_src

* Postamble
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
  (provide 'settings)

  ;;; settings.el ends here
#+END_SRC
